/* generated by riqtshaw */
#include "Bindings.h"
namespace {
struct option_bool {
public:
  bool value;
  bool some;
  operator QVariant() const {
    if (some) {
      return QVariant::fromValue(value);
    }
    return QVariant();
  }
};
static_assert(std::is_pod<option_bool>::value,
              "option_bool must be a POD type.");

struct option_qint64 {
public:
  qint64 value;
  bool some;
  operator QVariant() const {
    if (some) {
      return QVariant::fromValue(value);
    }
    return QVariant();
  }
};
static_assert(std::is_pod<option_qint64>::value,
              "option_qint64 must be a POD type.");

struct option_quint32 {
public:
  quint32 value;
  bool some;
  operator QVariant() const {
    if (some) {
      return QVariant::fromValue(value);
    }
    return QVariant();
  }
};
static_assert(std::is_pod<option_quint32>::value,
              "option_quint32 must be a POD type.");

struct option_quint8 {
public:
  quint8 value;
  bool some;
  operator QVariant() const {
    if (some) {
      return QVariant::fromValue(value);
    }
    return QVariant();
  }
};
static_assert(std::is_pod<option_quint8>::value,
              "option_quint8 must be a POD type.");

struct option_quintptr {
public:
  quintptr value;
  bool some;
  operator QVariant() const {
    if (some) {
      return QVariant::fromValue(value);
    }
    return QVariant();
  }
};
static_assert(std::is_pod<option_quintptr>::value,
              "option_quintptr must be a POD type.");
using qstring_set = void (*)(QString *val, const char *utf8, int nbytes);

void set_qstring(QString *val, const char *utf8, int nbytes) {
  *val = QString::fromUtf8(utf8, nbytes);
}

using qbytearray_set = void (*)(QByteArray *val, const char *bytes, int nbytes);

void set_qbytearray(QByteArray *v, const char *bytes, int nbytes) {
  if (v->isNull() && nbytes == 0) {
    *v = QByteArray(bytes, nbytes);
  } else {
    v->truncate(0);
    v->append(bytes, nbytes);
  }
}

struct qmodelindex_t {
  int row;
  quintptr id;
};

inline QVariant cleanNullQVariant(const QVariant &v) {
  return (v.isNull()) ? QVariant() : v;
}

inline void configColorChanged(Config *o) { Q_EMIT o->colorChanged(); }
inline void configColorschemeChanged(Config *o) {
  Q_EMIT o->colorschemeChanged();
}
inline void configConfigIdChanged(Config *o) { Q_EMIT o->configIdChanged(); }
inline void configNameChanged(Config *o) { Q_EMIT o->nameChanged(); }
inline void configNtsConversationIdChanged(Config *o) {
  Q_EMIT o->ntsConversationIdChanged();
}
inline void configPreferredExpirationChanged(Config *o) {
  Q_EMIT o->preferredExpirationChanged();
}
inline void configProfilePictureChanged(Config *o) {
  Q_EMIT o->profilePictureChanged();
}
inline void conversationBuilderPictureChanged(ConversationBuilder *o) {
  Q_EMIT o->pictureChanged();
}
inline void conversationContentConversationIdChanged(ConversationContent *o) {
  Q_EMIT o->conversationIdChanged();
}
inline void conversationsFilterChanged(Conversations *o) {
  Q_EMIT o->filterChanged();
}
inline void conversationsFilterRegexChanged(Conversations *o) {
  Q_EMIT o->filterRegexChanged();
}
inline void emojiPickerActivities_indexChanged(EmojiPicker *o) {
  Q_EMIT o->activities_indexChanged();
}
inline void emojiPickerBody_indexChanged(EmojiPicker *o) {
  Q_EMIT o->body_indexChanged();
}
inline void emojiPickerFlags_indexChanged(EmojiPicker *o) {
  Q_EMIT o->flags_indexChanged();
}
inline void emojiPickerFood_indexChanged(EmojiPicker *o) {
  Q_EMIT o->food_indexChanged();
}
inline void emojiPickerLocations_indexChanged(EmojiPicker *o) {
  Q_EMIT o->locations_indexChanged();
}
inline void emojiPickerNature_indexChanged(EmojiPicker *o) {
  Q_EMIT o->nature_indexChanged();
}
inline void emojiPickerObjects_indexChanged(EmojiPicker *o) {
  Q_EMIT o->objects_indexChanged();
}
inline void emojiPickerSmileys_indexChanged(EmojiPicker *o) {
  Q_EMIT o->smileys_indexChanged();
}
inline void emojiPickerSymbols_indexChanged(EmojiPicker *o) {
  Q_EMIT o->symbols_indexChanged();
}
inline void errorsTryPollChanged(Errors *o) { Q_EMIT o->tryPollChanged(); }
inline void heraldConfigInitChanged(Herald *o) {
  Q_EMIT o->configInitChanged();
}
inline void heraldConnectionPendingChanged(Herald *o) {
  Q_EMIT o->connectionPendingChanged();
}
inline void heraldConnectionUpChanged(Herald *o) {
  Q_EMIT o->connectionUpChanged();
}
inline void heraldRegistrationFailureCodeChanged(Herald *o) {
  Q_EMIT o->registrationFailureCodeChanged();
}
inline void membersFilterChanged(Members *o) { Q_EMIT o->filterChanged(); }
inline void membersFilterRegexChanged(Members *o) {
  Q_EMIT o->filterRegexChanged();
}
inline void messageBuilderBodyChanged(MessageBuilder *o) {
  Q_EMIT o->bodyChanged();
}
inline void messageBuilderHasDocAttachmentChanged(MessageBuilder *o) {
  Q_EMIT o->hasDocAttachmentChanged();
}
inline void messageBuilderHasMediaAttachmentChanged(MessageBuilder *o) {
  Q_EMIT o->hasMediaAttachmentChanged();
}
inline void messageBuilderIsReplyChanged(MessageBuilder *o) {
  Q_EMIT o->isReplyChanged();
}
inline void messageBuilderOpAuthorChanged(MessageBuilder *o) {
  Q_EMIT o->opAuthorChanged();
}
inline void messageBuilderOpBodyChanged(MessageBuilder *o) {
  Q_EMIT o->opBodyChanged();
}
inline void messageBuilderOpDocAttachmentsChanged(MessageBuilder *o) {
  Q_EMIT o->opDocAttachmentsChanged();
}
inline void messageBuilderOpExpirationTimeChanged(MessageBuilder *o) {
  Q_EMIT o->opExpirationTimeChanged();
}
inline void messageBuilderOpIdChanged(MessageBuilder *o) {
  Q_EMIT o->opIdChanged();
}
inline void messageBuilderOpMediaAttachmentsChanged(MessageBuilder *o) {
  Q_EMIT o->opMediaAttachmentsChanged();
}
inline void messageBuilderOpTimeChanged(MessageBuilder *o) {
  Q_EMIT o->opTimeChanged();
}
inline void messageSearchRegexSearchChanged(MessageSearch *o) {
  Q_EMIT o->regexSearchChanged();
}
inline void messageSearchSearchPatternChanged(MessageSearch *o) {
  Q_EMIT o->searchPatternChanged();
}
inline void messagesIsEmptyChanged(Messages *o) { Q_EMIT o->isEmptyChanged(); }
inline void messagesLastAuthorChanged(Messages *o) {
  Q_EMIT o->lastAuthorChanged();
}
inline void messagesLastBodyChanged(Messages *o) {
  Q_EMIT o->lastBodyChanged();
}
inline void messagesLastStatusChanged(Messages *o) {
  Q_EMIT o->lastStatusChanged();
}
inline void messagesLastTimeChanged(Messages *o) {
  Q_EMIT o->lastTimeChanged();
}
inline void messagesSearchActiveChanged(Messages *o) {
  Q_EMIT o->searchActiveChanged();
}
inline void messagesSearchIndexChanged(Messages *o) {
  Q_EMIT o->searchIndexChanged();
}
inline void messagesSearchNumMatchesChanged(Messages *o) {
  Q_EMIT o->searchNumMatchesChanged();
}
inline void messagesSearchPatternChanged(Messages *o) {
  Q_EMIT o->searchPatternChanged();
}
inline void messagesSearchRegexChanged(Messages *o) {
  Q_EMIT o->searchRegexChanged();
}
inline void usersFilterChanged(Users *o) { Q_EMIT o->filterChanged(); }
inline void usersFilterRegexChanged(Users *o) {
  Q_EMIT o->filterRegexChanged();
}
inline void usersSearchFilterChanged(UsersSearch *o) {
  Q_EMIT o->filterChanged();
}
} // namespace
extern "C" {
Config::Private *config_new(ConfigPtrBundle *);
void config_free(Config::Private *);
quint32 config_color_get(const Config::Private *);
void config_color_set(Config::Private *, quint32);
quint32 config_colorscheme_get(const Config::Private *);
void config_colorscheme_set(Config::Private *, quint32);
void config_config_id_get(const Config::Private *, QString *, qstring_set);
void config_name_get(const Config::Private *, QString *, qstring_set);
void config_name_set(Config::Private *, const ushort *str, int len);
void config_nts_conversation_id_get(const Config::Private *, QByteArray *,
                                    qbytearray_set);
quint8 config_preferred_expiration_get(const Config::Private *);
void config_preferred_expiration_set(Config::Private *, quint8);
void config_profile_picture_get(const Config::Private *, QString *,
                                qstring_set);
void config_set_profile_picture(Config::Private *, const ushort *, int);
}
extern "C" {
quint32
conversation_builder_data_member_color(const ConversationBuilder::Private *,
                                       int);
void conversation_builder_data_member_id(const ConversationBuilder::Private *,
                                         int, QString *, qstring_set);
void conversation_builder_data_member_name(const ConversationBuilder::Private *,
                                           int, QString *, qstring_set);
void conversation_builder_data_member_profile_picture(
    const ConversationBuilder::Private *, int, QString *, qstring_set);
void conversation_builder_sort(ConversationBuilder::Private *,
                               unsigned char column,
                               Qt::SortOrder order = Qt::AscendingOrder);
int conversation_builder_row_count(const ConversationBuilder::Private *);
bool conversation_builder_insert_rows(ConversationBuilder::Private *, int, int);
bool conversation_builder_remove_rows(ConversationBuilder::Private *, int, int);
bool conversation_builder_can_fetch_more(const ConversationBuilder::Private *);
void conversation_builder_fetch_more(ConversationBuilder::Private *);
}
int ConversationBuilder::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool ConversationBuilder::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int ConversationBuilder::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : conversation_builder_row_count(m_d);
}

bool ConversationBuilder::insertRows(int row, int count, const QModelIndex &) {
  return conversation_builder_insert_rows(m_d, row, count);
}

bool ConversationBuilder::removeRows(int row, int count, const QModelIndex &) {
  return conversation_builder_remove_rows(m_d, row, count);
}

QModelIndex ConversationBuilder::index(int row, int column,
                                       const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex ConversationBuilder::parent(const QModelIndex &) const {
  return {};
}

bool ConversationBuilder::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : conversation_builder_can_fetch_more(m_d);
}

void ConversationBuilder::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    conversation_builder_fetch_more(m_d);
  }
}
void ConversationBuilder::updatePersistentIndexes() {}

void ConversationBuilder::sort(int column, Qt::SortOrder order) {
  conversation_builder_sort(m_d, column, order);
}

Qt::ItemFlags ConversationBuilder::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

quint32 ConversationBuilder::memberColor(int row) const {
  return conversation_builder_data_member_color(m_d, row);
}

QString ConversationBuilder::memberId(int row) const {
  QString s;
  conversation_builder_data_member_id(m_d, row, &s, set_qstring);
  return s;
}

QString ConversationBuilder::memberName(int row) const {
  QString s;
  conversation_builder_data_member_name(m_d, row, &s, set_qstring);
  return s;
}

QString ConversationBuilder::memberProfilePicture(int row) const {
  QString s;
  conversation_builder_data_member_profile_picture(m_d, row, &s, set_qstring);
  return s;
}

QVariant ConversationBuilder::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(memberColor(index.row()));
    case Qt::UserRole + 1:
      return QVariant::fromValue(memberId(index.row()));
    case Qt::UserRole + 2:
      return QVariant::fromValue(memberName(index.row()));
    case Qt::UserRole + 3:
      return QVariant::fromValue(memberProfilePicture(index.row()));
    }
    break;
  }
  return QVariant();
}
int ConversationBuilder::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> ConversationBuilder::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "memberColor");
  names.insert(Qt::UserRole + 1, "memberId");
  names.insert(Qt::UserRole + 2, "memberName");
  names.insert(Qt::UserRole + 3, "memberProfilePicture");
  return names;
}

QVariant ConversationBuilder::headerData(int section,
                                         Qt::Orientation orientation,
                                         int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool ConversationBuilder::setHeaderData(int section,
                                        Qt::Orientation orientation,
                                        const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
ConversationBuilder::Private *
conversation_builder_new(ConversationBuilderPtrBundle *);
void conversation_builder_free(ConversationBuilder::Private *);
void conversation_builder_picture_get(const ConversationBuilder::Private *,
                                      QString *, qstring_set);
bool conversation_builder_add_member(ConversationBuilder::Private *,
                                     const ushort *, int);
void conversation_builder_clear(ConversationBuilder::Private *);
void conversation_builder_finalize(ConversationBuilder::Private *);
void conversation_builder_remove_last(ConversationBuilder::Private *);
bool conversation_builder_remove_member_by_id(ConversationBuilder::Private *,
                                              const ushort *, int);
bool conversation_builder_remove_member_by_index(ConversationBuilder::Private *,
                                                 quint64);
void conversation_builder_set_profile_picture(ConversationBuilder::Private *,
                                              const ushort *, int);
void conversation_builder_set_title(ConversationBuilder::Private *,
                                    const ushort *, int);
}
extern "C" {
void conversation_content_sort(ConversationContent::Private *,
                               unsigned char column,
                               Qt::SortOrder order = Qt::AscendingOrder);
int conversation_content_row_count(const ConversationContent::Private *);
bool conversation_content_insert_rows(ConversationContent::Private *, int, int);
bool conversation_content_remove_rows(ConversationContent::Private *, int, int);
bool conversation_content_can_fetch_more(const ConversationContent::Private *);
void conversation_content_fetch_more(ConversationContent::Private *);
}
int ConversationContent::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool ConversationContent::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int ConversationContent::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : conversation_content_row_count(m_d);
}

bool ConversationContent::insertRows(int row, int count, const QModelIndex &) {
  return conversation_content_insert_rows(m_d, row, count);
}

bool ConversationContent::removeRows(int row, int count, const QModelIndex &) {
  return conversation_content_remove_rows(m_d, row, count);
}

QModelIndex ConversationContent::index(int row, int column,
                                       const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex ConversationContent::parent(const QModelIndex &) const {
  return {};
}

bool ConversationContent::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : conversation_content_can_fetch_more(m_d);
}

void ConversationContent::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    conversation_content_fetch_more(m_d);
  }
}
void ConversationContent::updatePersistentIndexes() {}

void ConversationContent::sort(int column, Qt::SortOrder order) {
  conversation_content_sort(m_d, column, order);
}

Qt::ItemFlags ConversationContent::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QVariant ConversationContent::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {}
    break;
  }
  return QVariant();
}
int ConversationContent::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> ConversationContent::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  return names;
}

QVariant ConversationContent::headerData(int section,
                                         Qt::Orientation orientation,
                                         int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool ConversationContent::setHeaderData(int section,
                                        Qt::Orientation orientation,
                                        const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
ConversationContent::Private *
conversation_content_new(ConversationContentPtrBundle *);
void conversation_content_free(ConversationContent::Private *);
void conversation_content_conversation_id_get(
    const ConversationContent::Private *, QByteArray *, qbytearray_set);
void conversation_content_conversation_id_set(ConversationContent::Private *,
                                              const char *bytes, int len);
void conversation_content_conversation_id_set_none(
    ConversationContent::Private *);
Members::Private *
conversation_content_members_get(const ConversationContent::Private *);
Messages::Private *
conversation_content_messages_get(const ConversationContent::Private *);
}
extern "C" {
quint32 conversations_data_color(const Conversations::Private *, int);
bool conversations_set_data_color(Conversations::Private *, int, quint32);
void conversations_data_conversation_id(const Conversations::Private *, int,
                                        QByteArray *, qbytearray_set);
quint8 conversations_data_expiration_period(const Conversations::Private *,
                                            int);
bool conversations_set_data_expiration_period(Conversations::Private *, int,
                                              quint8);
bool conversations_data_matched(const Conversations::Private *, int);
bool conversations_data_muted(const Conversations::Private *, int);
bool conversations_set_data_muted(Conversations::Private *, int, bool);
bool conversations_data_pairwise(const Conversations::Private *, int);
void conversations_data_picture(const Conversations::Private *, int, QString *,
                                qstring_set);
quint8 conversations_data_status(const Conversations::Private *, int);
bool conversations_set_data_status(Conversations::Private *, int, quint8);
void conversations_data_title(const Conversations::Private *, int, QString *,
                              qstring_set);
bool conversations_set_data_title(Conversations::Private *, int,
                                  const ushort *s, int len);
bool conversations_set_data_title_none(Conversations::Private *, int);
void conversations_sort(Conversations::Private *, unsigned char column,
                        Qt::SortOrder order = Qt::AscendingOrder);
int conversations_row_count(const Conversations::Private *);
bool conversations_insert_rows(Conversations::Private *, int, int);
bool conversations_remove_rows(Conversations::Private *, int, int);
bool conversations_can_fetch_more(const Conversations::Private *);
void conversations_fetch_more(Conversations::Private *);
}
int Conversations::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool Conversations::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int Conversations::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : conversations_row_count(m_d);
}

bool Conversations::insertRows(int row, int count, const QModelIndex &) {
  return conversations_insert_rows(m_d, row, count);
}

bool Conversations::removeRows(int row, int count, const QModelIndex &) {
  return conversations_remove_rows(m_d, row, count);
}

QModelIndex Conversations::index(int row, int column,
                                 const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex Conversations::parent(const QModelIndex &) const { return {}; }

bool Conversations::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : conversations_can_fetch_more(m_d);
}

void Conversations::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    conversations_fetch_more(m_d);
  }
}
void Conversations::updatePersistentIndexes() {}

void Conversations::sort(int column, Qt::SortOrder order) {
  conversations_sort(m_d, column, order);
}

Qt::ItemFlags Conversations::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  if (i.column() == 0) {
    flags |= Qt::ItemIsEditable;
  }
  return flags;
}

quint32 Conversations::color(int row) const {
  return conversations_data_color(m_d, row);
}

bool Conversations::setColor(int row, quint32 value) {
  bool set = false;
  set = conversations_set_data_color(m_d, row, value);

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

QByteArray Conversations::conversationId(int row) const {
  QByteArray b;
  conversations_data_conversation_id(m_d, row, &b, set_qbytearray);
  return b;
}

quint8 Conversations::expirationPeriod(int row) const {
  return conversations_data_expiration_period(m_d, row);
}

bool Conversations::setExpirationPeriod(int row, quint8 value) {
  bool set = false;
  set = conversations_set_data_expiration_period(m_d, row, value);

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

bool Conversations::matched(int row) const {
  return conversations_data_matched(m_d, row);
}

bool Conversations::muted(int row) const {
  return conversations_data_muted(m_d, row);
}

bool Conversations::setMuted(int row, bool value) {
  bool set = false;
  set = conversations_set_data_muted(m_d, row, value);

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

bool Conversations::pairwise(int row) const {
  return conversations_data_pairwise(m_d, row);
}

QString Conversations::picture(int row) const {
  QString s;
  conversations_data_picture(m_d, row, &s, set_qstring);
  return s;
}

quint8 Conversations::status(int row) const {
  return conversations_data_status(m_d, row);
}

bool Conversations::setStatus(int row, quint8 value) {
  bool set = false;
  set = conversations_set_data_status(m_d, row, value);

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

QString Conversations::title(int row) const {
  QString s;
  conversations_data_title(m_d, row, &s, set_qstring);
  return s;
}

bool Conversations::setTitle(int row, const QString &value) {
  bool set = false;
  if (value.isNull()) {
    set = conversations_set_data_title_none(m_d, row);
  } else {
    set = conversations_set_data_title(m_d, row, value.utf16(), value.length());
  }

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

QVariant Conversations::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(color(index.row()));
    case Qt::UserRole + 1:
      return QVariant::fromValue(conversationId(index.row()));
    case Qt::UserRole + 2:
      return QVariant::fromValue(expirationPeriod(index.row()));
    case Qt::UserRole + 3:
      return QVariant::fromValue(matched(index.row()));
    case Qt::UserRole + 4:
      return QVariant::fromValue(muted(index.row()));
    case Qt::UserRole + 5:
      return QVariant::fromValue(pairwise(index.row()));
    case Qt::UserRole + 6:
      return cleanNullQVariant(QVariant::fromValue(picture(index.row())));
    case Qt::UserRole + 7:
      return QVariant::fromValue(status(index.row()));
    case Qt::UserRole + 8:
      return cleanNullQVariant(QVariant::fromValue(title(index.row())));
    }
    break;
  }
  return QVariant();
}
int Conversations::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> Conversations::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "color");
  names.insert(Qt::UserRole + 1, "conversationId");
  names.insert(Qt::UserRole + 2, "expirationPeriod");
  names.insert(Qt::UserRole + 3, "matched");
  names.insert(Qt::UserRole + 4, "muted");
  names.insert(Qt::UserRole + 5, "pairwise");
  names.insert(Qt::UserRole + 6, "picture");
  names.insert(Qt::UserRole + 7, "status");
  names.insert(Qt::UserRole + 8, "title");
  return names;
}

QVariant Conversations::headerData(int section, Qt::Orientation orientation,
                                   int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool Conversations::setHeaderData(int section, Qt::Orientation orientation,
                                  const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

bool Conversations::setData(const QModelIndex &index, const QVariant &value,
                            int role) {
  if (index.column() == 0) {
    if (role == Qt::UserRole + 0) {
      if (value.canConvert(qMetaTypeId<quint32>())) {
        return setColor(index.row(), value.value<quint32>());
      }
    }
    if (role == Qt::UserRole + 2) {
      if (value.canConvert(qMetaTypeId<quint8>())) {
        return setExpirationPeriod(index.row(), value.value<quint8>());
      }
    }
    if (role == Qt::UserRole + 4) {
      if (value.canConvert(qMetaTypeId<bool>())) {
        return setMuted(index.row(), value.value<bool>());
      }
    }
    if (role == Qt::UserRole + 7) {
      if (value.canConvert(qMetaTypeId<quint8>())) {
        return setStatus(index.row(), value.value<quint8>());
      }
    }
    if (role == Qt::UserRole + 8) {
      if (!value.isValid() || value.isNull() ||
          value.canConvert(qMetaTypeId<QString>())) {
        return setTitle(index.row(), value.value<QString>());
      }
    }
  }
  return false;
}

extern "C" {
Conversations::Private *conversations_new(ConversationsPtrBundle *);
void conversations_free(Conversations::Private *);
void conversations_filter_get(const Conversations::Private *, QString *,
                              qstring_set);
void conversations_filter_set(Conversations::Private *, const ushort *str,
                              int len);
bool conversations_filter_regex_get(const Conversations::Private *);
void conversations_filter_regex_set(Conversations::Private *, bool);
void conversations_clear_filter(Conversations::Private *);
qint64 conversations_index_by_id(const Conversations::Private *, const char *,
                                 int);
bool conversations_remove_conversation(Conversations::Private *, quint64);
void conversations_set_profile_picture(Conversations::Private *, quint64,
                                       const ushort *, int);
bool conversations_toggle_filter_regex(Conversations::Private *);
}
extern "C" {
void document_attachments_data_document_attachment_name(
    const DocumentAttachments::Private *, int, QString *, qstring_set);
quint64 document_attachments_data_document_attachment_size(
    const DocumentAttachments::Private *, int);
void document_attachments_sort(DocumentAttachments::Private *,
                               unsigned char column,
                               Qt::SortOrder order = Qt::AscendingOrder);
int document_attachments_row_count(const DocumentAttachments::Private *);
bool document_attachments_insert_rows(DocumentAttachments::Private *, int, int);
bool document_attachments_remove_rows(DocumentAttachments::Private *, int, int);
bool document_attachments_can_fetch_more(const DocumentAttachments::Private *);
void document_attachments_fetch_more(DocumentAttachments::Private *);
}
int DocumentAttachments::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool DocumentAttachments::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int DocumentAttachments::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : document_attachments_row_count(m_d);
}

bool DocumentAttachments::insertRows(int row, int count, const QModelIndex &) {
  return document_attachments_insert_rows(m_d, row, count);
}

bool DocumentAttachments::removeRows(int row, int count, const QModelIndex &) {
  return document_attachments_remove_rows(m_d, row, count);
}

QModelIndex DocumentAttachments::index(int row, int column,
                                       const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex DocumentAttachments::parent(const QModelIndex &) const {
  return {};
}

bool DocumentAttachments::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : document_attachments_can_fetch_more(m_d);
}

void DocumentAttachments::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    document_attachments_fetch_more(m_d);
  }
}
void DocumentAttachments::updatePersistentIndexes() {}

void DocumentAttachments::sort(int column, Qt::SortOrder order) {
  document_attachments_sort(m_d, column, order);
}

Qt::ItemFlags DocumentAttachments::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QString DocumentAttachments::documentAttachmentName(int row) const {
  QString s;
  document_attachments_data_document_attachment_name(m_d, row, &s, set_qstring);
  return s;
}

quint64 DocumentAttachments::documentAttachmentSize(int row) const {
  return document_attachments_data_document_attachment_size(m_d, row);
}

QVariant DocumentAttachments::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(documentAttachmentName(index.row()));
    case Qt::UserRole + 1:
      return QVariant::fromValue(documentAttachmentSize(index.row()));
    }
    break;
  }
  return QVariant();
}
int DocumentAttachments::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> DocumentAttachments::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "documentAttachmentName");
  names.insert(Qt::UserRole + 1, "documentAttachmentSize");
  return names;
}

QVariant DocumentAttachments::headerData(int section,
                                         Qt::Orientation orientation,
                                         int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool DocumentAttachments::setHeaderData(int section,
                                        Qt::Orientation orientation,
                                        const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
DocumentAttachments::Private *
document_attachments_new(DocumentAttachmentsPtrBundle *);
void document_attachments_free(DocumentAttachments::Private *);
}
extern "C" {
void emoji_picker_data_emoji(const EmojiPicker::Private *, int, QString *,
                             qstring_set);
bool emoji_picker_data_skintone_modifier(const EmojiPicker::Private *, int);
void emoji_picker_sort(EmojiPicker::Private *, unsigned char column,
                       Qt::SortOrder order = Qt::AscendingOrder);
int emoji_picker_row_count(const EmojiPicker::Private *);
bool emoji_picker_insert_rows(EmojiPicker::Private *, int, int);
bool emoji_picker_remove_rows(EmojiPicker::Private *, int, int);
bool emoji_picker_can_fetch_more(const EmojiPicker::Private *);
void emoji_picker_fetch_more(EmojiPicker::Private *);
}
int EmojiPicker::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool EmojiPicker::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int EmojiPicker::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : emoji_picker_row_count(m_d);
}

bool EmojiPicker::insertRows(int row, int count, const QModelIndex &) {
  return emoji_picker_insert_rows(m_d, row, count);
}

bool EmojiPicker::removeRows(int row, int count, const QModelIndex &) {
  return emoji_picker_remove_rows(m_d, row, count);
}

QModelIndex EmojiPicker::index(int row, int column,
                               const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex EmojiPicker::parent(const QModelIndex &) const { return {}; }

bool EmojiPicker::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : emoji_picker_can_fetch_more(m_d);
}

void EmojiPicker::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    emoji_picker_fetch_more(m_d);
  }
}
void EmojiPicker::updatePersistentIndexes() {}

void EmojiPicker::sort(int column, Qt::SortOrder order) {
  emoji_picker_sort(m_d, column, order);
}

Qt::ItemFlags EmojiPicker::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QString EmojiPicker::emoji(int row) const {
  QString s;
  emoji_picker_data_emoji(m_d, row, &s, set_qstring);
  return s;
}

bool EmojiPicker::skintone_modifier(int row) const {
  return emoji_picker_data_skintone_modifier(m_d, row);
}

QVariant EmojiPicker::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(emoji(index.row()));
    case Qt::UserRole + 1:
      return QVariant::fromValue(skintone_modifier(index.row()));
    }
    break;
  }
  return QVariant();
}
int EmojiPicker::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> EmojiPicker::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "emoji");
  names.insert(Qt::UserRole + 1, "skintone_modifier");
  return names;
}

QVariant EmojiPicker::headerData(int section, Qt::Orientation orientation,
                                 int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool EmojiPicker::setHeaderData(int section, Qt::Orientation orientation,
                                const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
EmojiPicker::Private *emoji_picker_new(EmojiPickerPtrBundle *);
void emoji_picker_free(EmojiPicker::Private *);
quint32 emoji_picker_activities_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_body_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_flags_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_food_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_locations_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_nature_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_objects_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_smileys_index_get(const EmojiPicker::Private *);
quint32 emoji_picker_symbols_index_get(const EmojiPicker::Private *);
void emoji_picker_clear_search(EmojiPicker::Private *);
void emoji_picker_set_search_string(EmojiPicker::Private *, const ushort *,
                                    int);
}
extern "C" {
Errors::Private *errors_new(ErrorsPtrBundle *);
void errors_free(Errors::Private *);
bool errors_try_poll_get(const Errors::Private *);
void errors_next_error(Errors::Private *, QString *, qstring_set);
}
extern "C" {
void herald_sort(Herald::Private *, unsigned char column,
                 Qt::SortOrder order = Qt::AscendingOrder);
int herald_row_count(const Herald::Private *);
bool herald_insert_rows(Herald::Private *, int, int);
bool herald_remove_rows(Herald::Private *, int, int);
bool herald_can_fetch_more(const Herald::Private *);
void herald_fetch_more(Herald::Private *);
}
int Herald::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool Herald::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int Herald::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : herald_row_count(m_d);
}

bool Herald::insertRows(int row, int count, const QModelIndex &) {
  return herald_insert_rows(m_d, row, count);
}

bool Herald::removeRows(int row, int count, const QModelIndex &) {
  return herald_remove_rows(m_d, row, count);
}

QModelIndex Herald::index(int row, int column,
                          const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex Herald::parent(const QModelIndex &) const { return {}; }

bool Herald::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : herald_can_fetch_more(m_d);
}

void Herald::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    herald_fetch_more(m_d);
  }
}
void Herald::updatePersistentIndexes() {}

void Herald::sort(int column, Qt::SortOrder order) {
  herald_sort(m_d, column, order);
}

Qt::ItemFlags Herald::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QVariant Herald::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {}
    break;
  }
  return QVariant();
}
int Herald::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> Herald::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  return names;
}

QVariant Herald::headerData(int section, Qt::Orientation orientation,
                            int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool Herald::setHeaderData(int section, Qt::Orientation orientation,
                           const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
Herald::Private *herald_new(HeraldPtrBundle *);
void herald_free(Herald::Private *);
Config::Private *herald_config_get(const Herald::Private *);
bool herald_config_init_get(const Herald::Private *);
bool herald_connection_pending_get(const Herald::Private *);
bool herald_connection_up_get(const Herald::Private *);
ConversationBuilder::Private *
herald_conversation_builder_get(const Herald::Private *);
Conversations::Private *herald_conversations_get(const Herald::Private *);
Errors::Private *herald_errors_get(const Herald::Private *);
MessageSearch::Private *herald_message_search_get(const Herald::Private *);
option_quint8 herald_registration_failure_code_get(const Herald::Private *);
Users::Private *herald_users_get(const Herald::Private *);
UsersSearch::Private *herald_users_search_get(const Herald::Private *);
Utils::Private *herald_utils_get(const Herald::Private *);
bool herald_login(Herald::Private *);
void herald_register_new_user(Herald::Private *, const ushort *, int,
                              const ushort *, int, const ushort *, int);
void herald_set_app_local_data_dir(Herald::Private *, const ushort *, int);
}
extern "C" {
void media_attachments_data_media_attachment_path(
    const MediaAttachments::Private *, int, QString *, qstring_set);
void media_attachments_sort(MediaAttachments::Private *, unsigned char column,
                            Qt::SortOrder order = Qt::AscendingOrder);
int media_attachments_row_count(const MediaAttachments::Private *);
bool media_attachments_insert_rows(MediaAttachments::Private *, int, int);
bool media_attachments_remove_rows(MediaAttachments::Private *, int, int);
bool media_attachments_can_fetch_more(const MediaAttachments::Private *);
void media_attachments_fetch_more(MediaAttachments::Private *);
}
int MediaAttachments::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool MediaAttachments::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int MediaAttachments::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : media_attachments_row_count(m_d);
}

bool MediaAttachments::insertRows(int row, int count, const QModelIndex &) {
  return media_attachments_insert_rows(m_d, row, count);
}

bool MediaAttachments::removeRows(int row, int count, const QModelIndex &) {
  return media_attachments_remove_rows(m_d, row, count);
}

QModelIndex MediaAttachments::index(int row, int column,
                                    const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex MediaAttachments::parent(const QModelIndex &) const { return {}; }

bool MediaAttachments::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : media_attachments_can_fetch_more(m_d);
}

void MediaAttachments::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    media_attachments_fetch_more(m_d);
  }
}
void MediaAttachments::updatePersistentIndexes() {}

void MediaAttachments::sort(int column, Qt::SortOrder order) {
  media_attachments_sort(m_d, column, order);
}

Qt::ItemFlags MediaAttachments::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QString MediaAttachments::mediaAttachmentPath(int row) const {
  QString s;
  media_attachments_data_media_attachment_path(m_d, row, &s, set_qstring);
  return s;
}

QVariant MediaAttachments::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(mediaAttachmentPath(index.row()));
    }
    break;
  }
  return QVariant();
}
int MediaAttachments::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> MediaAttachments::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "mediaAttachmentPath");
  return names;
}

QVariant MediaAttachments::headerData(int section, Qt::Orientation orientation,
                                      int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool MediaAttachments::setHeaderData(int section, Qt::Orientation orientation,
                                     const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
MediaAttachments::Private *media_attachments_new(MediaAttachmentsPtrBundle *);
void media_attachments_free(MediaAttachments::Private *);
}
extern "C" {
quint32 members_data_color(const Members::Private *, int);
bool members_data_matched(const Members::Private *, int);
void members_data_name(const Members::Private *, int, QString *, qstring_set);
void members_data_pairwise_conversation_id(const Members::Private *, int,
                                           QByteArray *, qbytearray_set);
void members_data_profile_picture(const Members::Private *, int, QString *,
                                  qstring_set);
quint8 members_data_status(const Members::Private *, int);
void members_data_user_id(const Members::Private *, int, QString *,
                          qstring_set);
void members_sort(Members::Private *, unsigned char column,
                  Qt::SortOrder order = Qt::AscendingOrder);
int members_row_count(const Members::Private *);
bool members_insert_rows(Members::Private *, int, int);
bool members_remove_rows(Members::Private *, int, int);
bool members_can_fetch_more(const Members::Private *);
void members_fetch_more(Members::Private *);
}
int Members::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool Members::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int Members::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : members_row_count(m_d);
}

bool Members::insertRows(int row, int count, const QModelIndex &) {
  return members_insert_rows(m_d, row, count);
}

bool Members::removeRows(int row, int count, const QModelIndex &) {
  return members_remove_rows(m_d, row, count);
}

QModelIndex Members::index(int row, int column,
                           const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex Members::parent(const QModelIndex &) const { return {}; }

bool Members::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : members_can_fetch_more(m_d);
}

void Members::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    members_fetch_more(m_d);
  }
}
void Members::updatePersistentIndexes() {}

void Members::sort(int column, Qt::SortOrder order) {
  members_sort(m_d, column, order);
}

Qt::ItemFlags Members::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

quint32 Members::color(int row) const { return members_data_color(m_d, row); }

bool Members::matched(int row) const { return members_data_matched(m_d, row); }

QString Members::name(int row) const {
  QString s;
  members_data_name(m_d, row, &s, set_qstring);
  return s;
}

QByteArray Members::pairwiseConversationId(int row) const {
  QByteArray b;
  members_data_pairwise_conversation_id(m_d, row, &b, set_qbytearray);
  return b;
}

QString Members::profilePicture(int row) const {
  QString s;
  members_data_profile_picture(m_d, row, &s, set_qstring);
  return s;
}

quint8 Members::status(int row) const { return members_data_status(m_d, row); }

QString Members::userId(int row) const {
  QString s;
  members_data_user_id(m_d, row, &s, set_qstring);
  return s;
}

QVariant Members::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(color(index.row()));
    case Qt::UserRole + 1:
      return QVariant::fromValue(matched(index.row()));
    case Qt::UserRole + 2:
      return QVariant::fromValue(name(index.row()));
    case Qt::UserRole + 3:
      return QVariant::fromValue(pairwiseConversationId(index.row()));
    case Qt::UserRole + 4:
      return cleanNullQVariant(
          QVariant::fromValue(profilePicture(index.row())));
    case Qt::UserRole + 5:
      return QVariant::fromValue(status(index.row()));
    case Qt::UserRole + 6:
      return QVariant::fromValue(userId(index.row()));
    }
    break;
  }
  return QVariant();
}
int Members::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> Members::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "color");
  names.insert(Qt::UserRole + 1, "matched");
  names.insert(Qt::UserRole + 2, "name");
  names.insert(Qt::UserRole + 3, "pairwiseConversationId");
  names.insert(Qt::UserRole + 4, "profilePicture");
  names.insert(Qt::UserRole + 5, "status");
  names.insert(Qt::UserRole + 6, "userId");
  return names;
}

QVariant Members::headerData(int section, Qt::Orientation orientation,
                             int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool Members::setHeaderData(int section, Qt::Orientation orientation,
                            const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
Members::Private *members_new(MembersPtrBundle *);
void members_free(Members::Private *);
void members_filter_get(const Members::Private *, QString *, qstring_set);
void members_filter_set(Members::Private *, const ushort *str, int len);
bool members_filter_regex_get(const Members::Private *);
void members_filter_regex_set(Members::Private *, bool);
bool members_add_to_conversation(Members::Private *, const ushort *, int);
bool members_remove_from_conversation_by_index(Members::Private *, quint64);
bool members_toggle_filter_regex(Members::Private *);
}
extern "C" {
void message_builder_sort(MessageBuilder::Private *, unsigned char column,
                          Qt::SortOrder order = Qt::AscendingOrder);
int message_builder_row_count(const MessageBuilder::Private *);
bool message_builder_insert_rows(MessageBuilder::Private *, int, int);
bool message_builder_remove_rows(MessageBuilder::Private *, int, int);
bool message_builder_can_fetch_more(const MessageBuilder::Private *);
void message_builder_fetch_more(MessageBuilder::Private *);
}
int MessageBuilder::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool MessageBuilder::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int MessageBuilder::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : message_builder_row_count(m_d);
}

bool MessageBuilder::insertRows(int row, int count, const QModelIndex &) {
  return message_builder_insert_rows(m_d, row, count);
}

bool MessageBuilder::removeRows(int row, int count, const QModelIndex &) {
  return message_builder_remove_rows(m_d, row, count);
}

QModelIndex MessageBuilder::index(int row, int column,
                                  const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex MessageBuilder::parent(const QModelIndex &) const { return {}; }

bool MessageBuilder::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : message_builder_can_fetch_more(m_d);
}

void MessageBuilder::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    message_builder_fetch_more(m_d);
  }
}
void MessageBuilder::updatePersistentIndexes() {}

void MessageBuilder::sort(int column, Qt::SortOrder order) {
  message_builder_sort(m_d, column, order);
}

Qt::ItemFlags MessageBuilder::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QVariant MessageBuilder::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {}
    break;
  }
  return QVariant();
}
int MessageBuilder::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> MessageBuilder::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  return names;
}

QVariant MessageBuilder::headerData(int section, Qt::Orientation orientation,
                                    int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool MessageBuilder::setHeaderData(int section, Qt::Orientation orientation,
                                   const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
MessageBuilder::Private *message_builder_new(MessageBuilderPtrBundle *);
void message_builder_free(MessageBuilder::Private *);
void message_builder_body_get(const MessageBuilder::Private *, QString *,
                              qstring_set);
void message_builder_body_set(MessageBuilder::Private *, const ushort *str,
                              int len);
void message_builder_body_set_none(MessageBuilder::Private *);
DocumentAttachments::Private *
message_builder_document_attachments_get(const MessageBuilder::Private *);
bool message_builder_has_doc_attachment_get(const MessageBuilder::Private *);
bool message_builder_has_media_attachment_get(const MessageBuilder::Private *);
bool message_builder_is_reply_get(const MessageBuilder::Private *);
MediaAttachments::Private *
message_builder_media_attachments_get(const MessageBuilder::Private *);
void message_builder_op_author_get(const MessageBuilder::Private *, QString *,
                                   qstring_set);
void message_builder_op_body_get(const MessageBuilder::Private *, QString *,
                                 qstring_set);
void message_builder_op_doc_attachments_get(const MessageBuilder::Private *,
                                            QString *, qstring_set);
option_qint64
message_builder_op_expiration_time_get(const MessageBuilder::Private *);
void message_builder_op_id_get(const MessageBuilder::Private *, QByteArray *,
                               qbytearray_set);
void message_builder_op_id_set(MessageBuilder::Private *, const char *bytes,
                               int len);
void message_builder_op_id_set_none(MessageBuilder::Private *);
void message_builder_op_media_attachments_get(const MessageBuilder::Private *,
                                              QString *, qstring_set);
option_qint64 message_builder_op_time_get(const MessageBuilder::Private *);
bool message_builder_add_attachment(MessageBuilder::Private *, const ushort *,
                                    int);
void message_builder_clear_reply(MessageBuilder::Private *);
void message_builder_finalize(MessageBuilder::Private *);
bool message_builder_remove_doc(MessageBuilder::Private *, quint64);
bool message_builder_remove_media(MessageBuilder::Private *, quint64);
}
extern "C" {
void message_search_data_after_first_match(const MessageSearch::Private *, int,
                                           QString *, qstring_set);
void message_search_data_author(const MessageSearch::Private *, int, QString *,
                                qstring_set);
void message_search_data_before_first_match(const MessageSearch::Private *, int,
                                            QString *, qstring_set);
void message_search_data_conversation(const MessageSearch::Private *, int,
                                      QByteArray *, qbytearray_set);
option_quint32
message_search_data_conversation_color(const MessageSearch::Private *, int);
option_bool
message_search_data_conversation_pairwise(const MessageSearch::Private *, int);
void message_search_data_conversation_picture(const MessageSearch::Private *,
                                              int, QString *, qstring_set);
void message_search_data_conversation_title(const MessageSearch::Private *, int,
                                            QString *, qstring_set);
void message_search_data_first_match(const MessageSearch::Private *, int,
                                     QString *, qstring_set);
void message_search_data_msg_id(const MessageSearch::Private *, int,
                                QByteArray *, qbytearray_set);
option_qint64 message_search_data_time(const MessageSearch::Private *, int);
void message_search_sort(MessageSearch::Private *, unsigned char column,
                         Qt::SortOrder order = Qt::AscendingOrder);
int message_search_row_count(const MessageSearch::Private *);
bool message_search_insert_rows(MessageSearch::Private *, int, int);
bool message_search_remove_rows(MessageSearch::Private *, int, int);
bool message_search_can_fetch_more(const MessageSearch::Private *);
void message_search_fetch_more(MessageSearch::Private *);
}
int MessageSearch::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool MessageSearch::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int MessageSearch::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : message_search_row_count(m_d);
}

bool MessageSearch::insertRows(int row, int count, const QModelIndex &) {
  return message_search_insert_rows(m_d, row, count);
}

bool MessageSearch::removeRows(int row, int count, const QModelIndex &) {
  return message_search_remove_rows(m_d, row, count);
}

QModelIndex MessageSearch::index(int row, int column,
                                 const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex MessageSearch::parent(const QModelIndex &) const { return {}; }

bool MessageSearch::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : message_search_can_fetch_more(m_d);
}

void MessageSearch::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    message_search_fetch_more(m_d);
  }
}
void MessageSearch::updatePersistentIndexes() {}

void MessageSearch::sort(int column, Qt::SortOrder order) {
  message_search_sort(m_d, column, order);
}

Qt::ItemFlags MessageSearch::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QString MessageSearch::afterFirstMatch(int row) const {
  QString s;
  message_search_data_after_first_match(m_d, row, &s, set_qstring);
  return s;
}

QString MessageSearch::author(int row) const {
  QString s;
  message_search_data_author(m_d, row, &s, set_qstring);
  return s;
}

QString MessageSearch::beforeFirstMatch(int row) const {
  QString s;
  message_search_data_before_first_match(m_d, row, &s, set_qstring);
  return s;
}

QByteArray MessageSearch::conversation(int row) const {
  QByteArray b;
  message_search_data_conversation(m_d, row, &b, set_qbytearray);
  return b;
}

QVariant MessageSearch::conversationColor(int row) const {
  QVariant v;
  v = message_search_data_conversation_color(m_d, row);
  return v;
}

QVariant MessageSearch::conversationPairwise(int row) const {
  QVariant v;
  v = message_search_data_conversation_pairwise(m_d, row);
  return v;
}

QString MessageSearch::conversationPicture(int row) const {
  QString s;
  message_search_data_conversation_picture(m_d, row, &s, set_qstring);
  return s;
}

QString MessageSearch::conversationTitle(int row) const {
  QString s;
  message_search_data_conversation_title(m_d, row, &s, set_qstring);
  return s;
}

QString MessageSearch::firstMatch(int row) const {
  QString s;
  message_search_data_first_match(m_d, row, &s, set_qstring);
  return s;
}

QByteArray MessageSearch::msgId(int row) const {
  QByteArray b;
  message_search_data_msg_id(m_d, row, &b, set_qbytearray);
  return b;
}

QVariant MessageSearch::time(int row) const {
  QVariant v;
  v = message_search_data_time(m_d, row);
  return v;
}

QVariant MessageSearch::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(afterFirstMatch(index.row()));
    case Qt::UserRole + 1:
      return cleanNullQVariant(QVariant::fromValue(author(index.row())));
    case Qt::UserRole + 2:
      return QVariant::fromValue(beforeFirstMatch(index.row()));
    case Qt::UserRole + 3:
      return cleanNullQVariant(QVariant::fromValue(conversation(index.row())));
    case Qt::UserRole + 4:
      return conversationColor(index.row());
    case Qt::UserRole + 5:
      return conversationPairwise(index.row());
    case Qt::UserRole + 6:
      return cleanNullQVariant(
          QVariant::fromValue(conversationPicture(index.row())));
    case Qt::UserRole + 7:
      return cleanNullQVariant(
          QVariant::fromValue(conversationTitle(index.row())));
    case Qt::UserRole + 8:
      return QVariant::fromValue(firstMatch(index.row()));
    case Qt::UserRole + 9:
      return cleanNullQVariant(QVariant::fromValue(msgId(index.row())));
    case Qt::UserRole + 10:
      return time(index.row());
    }
    break;
  }
  return QVariant();
}
int MessageSearch::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> MessageSearch::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "afterFirstMatch");
  names.insert(Qt::UserRole + 1, "author");
  names.insert(Qt::UserRole + 2, "beforeFirstMatch");
  names.insert(Qt::UserRole + 3, "conversation");
  names.insert(Qt::UserRole + 4, "conversationColor");
  names.insert(Qt::UserRole + 5, "conversationPairwise");
  names.insert(Qt::UserRole + 6, "conversationPicture");
  names.insert(Qt::UserRole + 7, "conversationTitle");
  names.insert(Qt::UserRole + 8, "firstMatch");
  names.insert(Qt::UserRole + 9, "msgId");
  names.insert(Qt::UserRole + 10, "time");
  return names;
}

QVariant MessageSearch::headerData(int section, Qt::Orientation orientation,
                                   int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool MessageSearch::setHeaderData(int section, Qt::Orientation orientation,
                                  const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
MessageSearch::Private *message_search_new(MessageSearchPtrBundle *);
void message_search_free(MessageSearch::Private *);
option_bool message_search_regex_search_get(const MessageSearch::Private *);
void message_search_regex_search_set(MessageSearch::Private *, bool);
void message_search_regex_search_set_none(MessageSearch::Private *);
void message_search_search_pattern_get(const MessageSearch::Private *,
                                       QString *, qstring_set);
void message_search_search_pattern_set(MessageSearch::Private *,
                                       const ushort *str, int len);
void message_search_search_pattern_set_none(MessageSearch::Private *);
void message_search_clear_search(MessageSearch::Private *);
}
extern "C" {
void messages_data_author(const Messages::Private *, int, QString *,
                          qstring_set);
option_quint32 messages_data_author_color(const Messages::Private *, int);
void messages_data_author_name(const Messages::Private *, int, QString *,
                               qstring_set);
void messages_data_author_profile_picture(const Messages::Private *, int,
                                          QString *, qstring_set);
void messages_data_aux_data(const Messages::Private *, int, QString *,
                            qstring_set);
void messages_data_body(const Messages::Private *, int, QString *, qstring_set);
void messages_data_doc_attachments(const Messages::Private *, int, QString *,
                                   qstring_set);
option_qint64 messages_data_expiration_time(const Messages::Private *, int);
void messages_data_full_body(const Messages::Private *, int, QString *,
                             qstring_set);
void messages_data_full_media_attachments(const Messages::Private *, int,
                                          QString *, qstring_set);
option_qint64 messages_data_insertion_time(const Messages::Private *, int);
option_bool messages_data_is_head(const Messages::Private *, int);
option_bool messages_data_is_tail(const Messages::Private *, int);
option_quint8 messages_data_match_status(const Messages::Private *, int);
void messages_data_media_attachments(const Messages::Private *, int, QString *,
                                     qstring_set);
void messages_data_msg_id(const Messages::Private *, int, QByteArray *,
                          qbytearray_set);
void messages_data_op_author(const Messages::Private *, int, QString *,
                             qstring_set);
void messages_data_op_body(const Messages::Private *, int, QString *,
                           qstring_set);
option_quint32 messages_data_op_color(const Messages::Private *, int);
void messages_data_op_doc_attachments(const Messages::Private *, int, QString *,
                                      qstring_set);
option_qint64 messages_data_op_expiration_time(const Messages::Private *, int);
option_qint64 messages_data_op_insertion_time(const Messages::Private *, int);
void messages_data_op_media_attachments(const Messages::Private *, int,
                                        QString *, qstring_set);
void messages_data_op_msg_id(const Messages::Private *, int, QByteArray *,
                             qbytearray_set);
void messages_data_op_name(const Messages::Private *, int, QString *,
                           qstring_set);
void messages_data_reactions(const Messages::Private *, int, QString *,
                             qstring_set);
option_quint32 messages_data_receipt_status(const Messages::Private *, int);
option_quint8 messages_data_reply_type(const Messages::Private *, int);
option_qint64 messages_data_server_time(const Messages::Private *, int);
void messages_data_user_receipts(const Messages::Private *, int, QString *,
                                 qstring_set);
void messages_sort(Messages::Private *, unsigned char column,
                   Qt::SortOrder order = Qt::AscendingOrder);
int messages_row_count(const Messages::Private *);
bool messages_insert_rows(Messages::Private *, int, int);
bool messages_remove_rows(Messages::Private *, int, int);
bool messages_can_fetch_more(const Messages::Private *);
void messages_fetch_more(Messages::Private *);
}
int Messages::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool Messages::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int Messages::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : messages_row_count(m_d);
}

bool Messages::insertRows(int row, int count, const QModelIndex &) {
  return messages_insert_rows(m_d, row, count);
}

bool Messages::removeRows(int row, int count, const QModelIndex &) {
  return messages_remove_rows(m_d, row, count);
}

QModelIndex Messages::index(int row, int column,
                            const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex Messages::parent(const QModelIndex &) const { return {}; }

bool Messages::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : messages_can_fetch_more(m_d);
}

void Messages::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    messages_fetch_more(m_d);
  }
}
void Messages::updatePersistentIndexes() {}

void Messages::sort(int column, Qt::SortOrder order) {
  messages_sort(m_d, column, order);
}

Qt::ItemFlags Messages::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  return flags;
}

QString Messages::author(int row) const {
  QString s;
  messages_data_author(m_d, row, &s, set_qstring);
  return s;
}

QVariant Messages::authorColor(int row) const {
  QVariant v;
  v = messages_data_author_color(m_d, row);
  return v;
}

QString Messages::authorName(int row) const {
  QString s;
  messages_data_author_name(m_d, row, &s, set_qstring);
  return s;
}

QString Messages::authorProfilePicture(int row) const {
  QString s;
  messages_data_author_profile_picture(m_d, row, &s, set_qstring);
  return s;
}

QString Messages::auxData(int row) const {
  QString s;
  messages_data_aux_data(m_d, row, &s, set_qstring);
  return s;
}

QString Messages::body(int row) const {
  QString s;
  messages_data_body(m_d, row, &s, set_qstring);
  return s;
}

QString Messages::docAttachments(int row) const {
  QString s;
  messages_data_doc_attachments(m_d, row, &s, set_qstring);
  return s;
}

QVariant Messages::expirationTime(int row) const {
  QVariant v;
  v = messages_data_expiration_time(m_d, row);
  return v;
}

QString Messages::fullBody(int row) const {
  QString s;
  messages_data_full_body(m_d, row, &s, set_qstring);
  return s;
}

QString Messages::fullMediaAttachments(int row) const {
  QString s;
  messages_data_full_media_attachments(m_d, row, &s, set_qstring);
  return s;
}

QVariant Messages::insertionTime(int row) const {
  QVariant v;
  v = messages_data_insertion_time(m_d, row);
  return v;
}

QVariant Messages::isHead(int row) const {
  QVariant v;
  v = messages_data_is_head(m_d, row);
  return v;
}

QVariant Messages::isTail(int row) const {
  QVariant v;
  v = messages_data_is_tail(m_d, row);
  return v;
}

QVariant Messages::matchStatus(int row) const {
  QVariant v;
  v = messages_data_match_status(m_d, row);
  return v;
}

QString Messages::mediaAttachments(int row) const {
  QString s;
  messages_data_media_attachments(m_d, row, &s, set_qstring);
  return s;
}

QByteArray Messages::msgId(int row) const {
  QByteArray b;
  messages_data_msg_id(m_d, row, &b, set_qbytearray);
  return b;
}

QString Messages::opAuthor(int row) const {
  QString s;
  messages_data_op_author(m_d, row, &s, set_qstring);
  return s;
}

QString Messages::opBody(int row) const {
  QString s;
  messages_data_op_body(m_d, row, &s, set_qstring);
  return s;
}

QVariant Messages::opColor(int row) const {
  QVariant v;
  v = messages_data_op_color(m_d, row);
  return v;
}

QString Messages::opDocAttachments(int row) const {
  QString s;
  messages_data_op_doc_attachments(m_d, row, &s, set_qstring);
  return s;
}

QVariant Messages::opExpirationTime(int row) const {
  QVariant v;
  v = messages_data_op_expiration_time(m_d, row);
  return v;
}

QVariant Messages::opInsertionTime(int row) const {
  QVariant v;
  v = messages_data_op_insertion_time(m_d, row);
  return v;
}

QString Messages::opMediaAttachments(int row) const {
  QString s;
  messages_data_op_media_attachments(m_d, row, &s, set_qstring);
  return s;
}

QByteArray Messages::opMsgId(int row) const {
  QByteArray b;
  messages_data_op_msg_id(m_d, row, &b, set_qbytearray);
  return b;
}

QString Messages::opName(int row) const {
  QString s;
  messages_data_op_name(m_d, row, &s, set_qstring);
  return s;
}

QString Messages::reactions(int row) const {
  QString s;
  messages_data_reactions(m_d, row, &s, set_qstring);
  return s;
}

QVariant Messages::receiptStatus(int row) const {
  QVariant v;
  v = messages_data_receipt_status(m_d, row);
  return v;
}

QVariant Messages::replyType(int row) const {
  QVariant v;
  v = messages_data_reply_type(m_d, row);
  return v;
}

QVariant Messages::serverTime(int row) const {
  QVariant v;
  v = messages_data_server_time(m_d, row);
  return v;
}

QString Messages::userReceipts(int row) const {
  QString s;
  messages_data_user_receipts(m_d, row, &s, set_qstring);
  return s;
}

QVariant Messages::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return cleanNullQVariant(QVariant::fromValue(author(index.row())));
    case Qt::UserRole + 1:
      return authorColor(index.row());
    case Qt::UserRole + 2:
      return cleanNullQVariant(QVariant::fromValue(authorName(index.row())));
    case Qt::UserRole + 3:
      return QVariant::fromValue(authorProfilePicture(index.row()));
    case Qt::UserRole + 4:
      return QVariant::fromValue(auxData(index.row()));
    case Qt::UserRole + 5:
      return QVariant::fromValue(body(index.row()));
    case Qt::UserRole + 6:
      return QVariant::fromValue(docAttachments(index.row()));
    case Qt::UserRole + 7:
      return expirationTime(index.row());
    case Qt::UserRole + 8:
      return QVariant::fromValue(fullBody(index.row()));
    case Qt::UserRole + 9:
      return QVariant::fromValue(fullMediaAttachments(index.row()));
    case Qt::UserRole + 10:
      return insertionTime(index.row());
    case Qt::UserRole + 11:
      return isHead(index.row());
    case Qt::UserRole + 12:
      return isTail(index.row());
    case Qt::UserRole + 13:
      return matchStatus(index.row());
    case Qt::UserRole + 14:
      return QVariant::fromValue(mediaAttachments(index.row()));
    case Qt::UserRole + 15:
      return cleanNullQVariant(QVariant::fromValue(msgId(index.row())));
    case Qt::UserRole + 16:
      return cleanNullQVariant(QVariant::fromValue(opAuthor(index.row())));
    case Qt::UserRole + 17:
      return QVariant::fromValue(opBody(index.row()));
    case Qt::UserRole + 18:
      return opColor(index.row());
    case Qt::UserRole + 19:
      return QVariant::fromValue(opDocAttachments(index.row()));
    case Qt::UserRole + 20:
      return opExpirationTime(index.row());
    case Qt::UserRole + 21:
      return opInsertionTime(index.row());
    case Qt::UserRole + 22:
      return QVariant::fromValue(opMediaAttachments(index.row()));
    case Qt::UserRole + 23:
      return cleanNullQVariant(QVariant::fromValue(opMsgId(index.row())));
    case Qt::UserRole + 24:
      return cleanNullQVariant(QVariant::fromValue(opName(index.row())));
    case Qt::UserRole + 25:
      return QVariant::fromValue(reactions(index.row()));
    case Qt::UserRole + 26:
      return receiptStatus(index.row());
    case Qt::UserRole + 27:
      return replyType(index.row());
    case Qt::UserRole + 28:
      return serverTime(index.row());
    case Qt::UserRole + 29:
      return QVariant::fromValue(userReceipts(index.row()));
    }
    break;
  }
  return QVariant();
}
int Messages::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> Messages::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "author");
  names.insert(Qt::UserRole + 1, "authorColor");
  names.insert(Qt::UserRole + 2, "authorName");
  names.insert(Qt::UserRole + 3, "authorProfilePicture");
  names.insert(Qt::UserRole + 4, "auxData");
  names.insert(Qt::UserRole + 5, "body");
  names.insert(Qt::UserRole + 6, "docAttachments");
  names.insert(Qt::UserRole + 7, "expirationTime");
  names.insert(Qt::UserRole + 8, "fullBody");
  names.insert(Qt::UserRole + 9, "fullMediaAttachments");
  names.insert(Qt::UserRole + 10, "insertionTime");
  names.insert(Qt::UserRole + 11, "isHead");
  names.insert(Qt::UserRole + 12, "isTail");
  names.insert(Qt::UserRole + 13, "matchStatus");
  names.insert(Qt::UserRole + 14, "mediaAttachments");
  names.insert(Qt::UserRole + 15, "msgId");
  names.insert(Qt::UserRole + 16, "opAuthor");
  names.insert(Qt::UserRole + 17, "opBody");
  names.insert(Qt::UserRole + 18, "opColor");
  names.insert(Qt::UserRole + 19, "opDocAttachments");
  names.insert(Qt::UserRole + 20, "opExpirationTime");
  names.insert(Qt::UserRole + 21, "opInsertionTime");
  names.insert(Qt::UserRole + 22, "opMediaAttachments");
  names.insert(Qt::UserRole + 23, "opMsgId");
  names.insert(Qt::UserRole + 24, "opName");
  names.insert(Qt::UserRole + 25, "reactions");
  names.insert(Qt::UserRole + 26, "receiptStatus");
  names.insert(Qt::UserRole + 27, "replyType");
  names.insert(Qt::UserRole + 28, "serverTime");
  names.insert(Qt::UserRole + 29, "userReceipts");
  return names;
}

QVariant Messages::headerData(int section, Qt::Orientation orientation,
                              int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool Messages::setHeaderData(int section, Qt::Orientation orientation,
                             const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

extern "C" {
Messages::Private *messages_new(MessagesPtrBundle *);
void messages_free(Messages::Private *);
MessageBuilder::Private *messages_builder_get(const Messages::Private *);
bool messages_is_empty_get(const Messages::Private *);
void messages_last_author_get(const Messages::Private *, QString *,
                              qstring_set);
void messages_last_body_get(const Messages::Private *, QString *, qstring_set);
option_quint32 messages_last_status_get(const Messages::Private *);
option_qint64 messages_last_time_get(const Messages::Private *);
bool messages_search_active_get(const Messages::Private *);
void messages_search_active_set(Messages::Private *, bool);
quint64 messages_search_index_get(const Messages::Private *);
quint64 messages_search_num_matches_get(const Messages::Private *);
void messages_search_pattern_get(const Messages::Private *, QString *,
                                 qstring_set);
void messages_search_pattern_set(Messages::Private *, const ushort *str,
                                 int len);
bool messages_search_regex_get(const Messages::Private *);
void messages_search_regex_set(Messages::Private *, bool);
void messages_add_reaction(Messages::Private *, quint64, const ushort *, int);
bool messages_clear_conversation_history(Messages::Private *);
void messages_clear_search(Messages::Private *);
bool messages_delete_message(Messages::Private *, quint64);
qint64 messages_index_by_id(const Messages::Private *, const char *, int);
void messages_mark_read(Messages::Private *, quint64);
qint64 messages_next_search_match(Messages::Private *);
qint64 messages_prev_search_match(Messages::Private *);
void messages_remove_reaction(Messages::Private *, quint64, const ushort *,
                              int);
bool messages_save_all_attachments(const Messages::Private *, quint64,
                                   const ushort *, int);
void messages_set_elision_char_count(Messages::Private *, quint16);
void messages_set_elision_chars_per_line(Messages::Private *, quint8);
void messages_set_elision_line_count(Messages::Private *, quint8);
void messages_set_search_hint(Messages::Private *, float, float);
}
extern "C" {
quint32 users_data_color(const Users::Private *, int);
bool users_set_data_color(Users::Private *, int, quint32);
bool users_data_matched(const Users::Private *, int);
void users_data_name(const Users::Private *, int, QString *, qstring_set);
bool users_set_data_name(Users::Private *, int, const ushort *s, int len);
void users_data_pairwise_conversation_id(const Users::Private *, int,
                                         QByteArray *, qbytearray_set);
void users_data_profile_picture(const Users::Private *, int, QString *,
                                qstring_set);
quint8 users_data_status(const Users::Private *, int);
bool users_set_data_status(Users::Private *, int, quint8);
void users_data_user_id(const Users::Private *, int, QString *, qstring_set);
void users_sort(Users::Private *, unsigned char column,
                Qt::SortOrder order = Qt::AscendingOrder);
int users_row_count(const Users::Private *);
bool users_insert_rows(Users::Private *, int, int);
bool users_remove_rows(Users::Private *, int, int);
bool users_can_fetch_more(const Users::Private *);
void users_fetch_more(Users::Private *);
}
int Users::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool Users::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int Users::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : users_row_count(m_d);
}

bool Users::insertRows(int row, int count, const QModelIndex &) {
  return users_insert_rows(m_d, row, count);
}

bool Users::removeRows(int row, int count, const QModelIndex &) {
  return users_remove_rows(m_d, row, count);
}

QModelIndex Users::index(int row, int column, const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex Users::parent(const QModelIndex &) const { return {}; }

bool Users::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : users_can_fetch_more(m_d);
}

void Users::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    users_fetch_more(m_d);
  }
}
void Users::updatePersistentIndexes() {}

void Users::sort(int column, Qt::SortOrder order) {
  users_sort(m_d, column, order);
}

Qt::ItemFlags Users::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  if (i.column() == 0) {
    flags |= Qt::ItemIsEditable;
  }
  return flags;
}

quint32 Users::color(int row) const { return users_data_color(m_d, row); }

bool Users::setColor(int row, quint32 value) {
  bool set = false;
  set = users_set_data_color(m_d, row, value);

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

bool Users::matched(int row) const { return users_data_matched(m_d, row); }

QString Users::name(int row) const {
  QString s;
  users_data_name(m_d, row, &s, set_qstring);
  return s;
}

bool Users::setName(int row, const QString &value) {
  bool set = false;
  set = users_set_data_name(m_d, row, value.utf16(), value.length());

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

QByteArray Users::pairwiseConversationId(int row) const {
  QByteArray b;
  users_data_pairwise_conversation_id(m_d, row, &b, set_qbytearray);
  return b;
}

QString Users::profilePicture(int row) const {
  QString s;
  users_data_profile_picture(m_d, row, &s, set_qstring);
  return s;
}

quint8 Users::status(int row) const { return users_data_status(m_d, row); }

bool Users::setStatus(int row, quint8 value) {
  bool set = false;
  set = users_set_data_status(m_d, row, value);

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

QString Users::userId(int row) const {
  QString s;
  users_data_user_id(m_d, row, &s, set_qstring);
  return s;
}

QVariant Users::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return QVariant::fromValue(color(index.row()));
    case Qt::UserRole + 1:
      return QVariant::fromValue(matched(index.row()));
    case Qt::UserRole + 2:
      return QVariant::fromValue(name(index.row()));
    case Qt::UserRole + 3:
      return QVariant::fromValue(pairwiseConversationId(index.row()));
    case Qt::UserRole + 4:
      return cleanNullQVariant(
          QVariant::fromValue(profilePicture(index.row())));
    case Qt::UserRole + 5:
      return QVariant::fromValue(status(index.row()));
    case Qt::UserRole + 6:
      return QVariant::fromValue(userId(index.row()));
    }
    break;
  }
  return QVariant();
}
int Users::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> Users::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "color");
  names.insert(Qt::UserRole + 1, "matched");
  names.insert(Qt::UserRole + 2, "name");
  names.insert(Qt::UserRole + 3, "pairwiseConversationId");
  names.insert(Qt::UserRole + 4, "profilePicture");
  names.insert(Qt::UserRole + 5, "status");
  names.insert(Qt::UserRole + 6, "userId");
  return names;
}

QVariant Users::headerData(int section, Qt::Orientation orientation,
                           int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool Users::setHeaderData(int section, Qt::Orientation orientation,
                          const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

bool Users::setData(const QModelIndex &index, const QVariant &value, int role) {
  if (index.column() == 0) {
    if (role == Qt::UserRole + 0) {
      if (value.canConvert(qMetaTypeId<quint32>())) {
        return setColor(index.row(), value.value<quint32>());
      }
    }
    if (role == Qt::UserRole + 2) {
      if (value.canConvert(qMetaTypeId<QString>())) {
        return setName(index.row(), value.value<QString>());
      }
    }
    if (role == Qt::UserRole + 5) {
      if (value.canConvert(qMetaTypeId<quint8>())) {
        return setStatus(index.row(), value.value<quint8>());
      }
    }
  }
  return false;
}

extern "C" {
Users::Private *users_new(UsersPtrBundle *);
void users_free(Users::Private *);
void users_filter_get(const Users::Private *, QString *, qstring_set);
void users_filter_set(Users::Private *, const ushort *str, int len);
bool users_filter_regex_get(const Users::Private *);
void users_filter_regex_set(Users::Private *, bool);
void users_add(Users::Private *, const ushort *, int, QByteArray *,
               qbytearray_set);
void users_clear_filter(Users::Private *);
quint32 users_color_by_id(const Users::Private *, const ushort *, int);
void users_name_by_id(const Users::Private *, const ushort *, int, QString *,
                      qstring_set);
void users_profile_picture_by_id(const Users::Private *, const ushort *, int,
                                 QString *, qstring_set);
void users_set_profile_picture(Users::Private *, quint64, const ushort *, int);
bool users_toggle_filter_regex(Users::Private *);
}
extern "C" {
option_quint32 users_search_data_color(const UsersSearch::Private *, int);
bool users_search_data_matched(const UsersSearch::Private *, int);
void users_search_data_name(const UsersSearch::Private *, int, QString *,
                            qstring_set);
void users_search_data_profile_picture(const UsersSearch::Private *, int,
                                       QString *, qstring_set);
bool users_search_data_selected(const UsersSearch::Private *, int);
bool users_search_set_data_selected(UsersSearch::Private *, int, bool);
void users_search_data_user_id(const UsersSearch::Private *, int, QString *,
                               qstring_set);
void users_search_sort(UsersSearch::Private *, unsigned char column,
                       Qt::SortOrder order = Qt::AscendingOrder);
int users_search_row_count(const UsersSearch::Private *);
bool users_search_insert_rows(UsersSearch::Private *, int, int);
bool users_search_remove_rows(UsersSearch::Private *, int, int);
bool users_search_can_fetch_more(const UsersSearch::Private *);
void users_search_fetch_more(UsersSearch::Private *);
}
int UsersSearch::columnCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : 1;
}

bool UsersSearch::hasChildren(const QModelIndex &parent) const {
  return rowCount(parent) > 0;
}

int UsersSearch::rowCount(const QModelIndex &parent) const {
  return (parent.isValid()) ? 0 : users_search_row_count(m_d);
}

bool UsersSearch::insertRows(int row, int count, const QModelIndex &) {
  return users_search_insert_rows(m_d, row, count);
}

bool UsersSearch::removeRows(int row, int count, const QModelIndex &) {
  return users_search_remove_rows(m_d, row, count);
}

QModelIndex UsersSearch::index(int row, int column,
                               const QModelIndex &parent) const {
  if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 &&
      column < 1) {
    return createIndex(row, column, static_cast<quintptr>(row));
  }
  return {};
}

QModelIndex UsersSearch::parent(const QModelIndex &) const { return {}; }

bool UsersSearch::canFetchMore(const QModelIndex &parent) const {
  return (parent.isValid()) ? false : users_search_can_fetch_more(m_d);
}

void UsersSearch::fetchMore(const QModelIndex &parent) {
  if (!parent.isValid()) {
    users_search_fetch_more(m_d);
  }
}
void UsersSearch::updatePersistentIndexes() {}

void UsersSearch::sort(int column, Qt::SortOrder order) {
  users_search_sort(m_d, column, order);
}

Qt::ItemFlags UsersSearch::flags(const QModelIndex &i) const {
  auto flags = QAbstractItemModel::flags(i);
  if (i.column() == 0) {
    flags |= Qt::ItemIsEditable;
  }
  return flags;
}

QVariant UsersSearch::color(int row) const {
  QVariant v;
  v = users_search_data_color(m_d, row);
  return v;
}

bool UsersSearch::matched(int row) const {
  return users_search_data_matched(m_d, row);
}

QString UsersSearch::name(int row) const {
  QString s;
  users_search_data_name(m_d, row, &s, set_qstring);
  return s;
}

QString UsersSearch::profilePicture(int row) const {
  QString s;
  users_search_data_profile_picture(m_d, row, &s, set_qstring);
  return s;
}

bool UsersSearch::selected(int row) const {
  return users_search_data_selected(m_d, row);
}

bool UsersSearch::setSelected(int row, bool value) {
  bool set = false;
  set = users_search_set_data_selected(m_d, row, value);

  if (set) {
    QModelIndex index = createIndex(row, 0, row);
    Q_EMIT dataChanged(index, index);
  }
  return set;
}

QString UsersSearch::userId(int row) const {
  QString s;
  users_search_data_user_id(m_d, row, &s, set_qstring);
  return s;
}

QVariant UsersSearch::data(const QModelIndex &index, int role) const {
  Q_ASSERT(rowCount(index.parent()) > index.row());
  switch (index.column()) {
  case 0:
    switch (role) {
    case Qt::UserRole + 0:
      return color(index.row());
    case Qt::UserRole + 1:
      return QVariant::fromValue(matched(index.row()));
    case Qt::UserRole + 2:
      return cleanNullQVariant(QVariant::fromValue(name(index.row())));
    case Qt::UserRole + 3:
      return cleanNullQVariant(
          QVariant::fromValue(profilePicture(index.row())));
    case Qt::UserRole + 4:
      return QVariant::fromValue(selected(index.row()));
    case Qt::UserRole + 5:
      return cleanNullQVariant(QVariant::fromValue(userId(index.row())));
    }
    break;
  }
  return QVariant();
}
int UsersSearch::role(const char *name) const {
  auto names = roleNames();
  auto i = names.constBegin();
  while (i != names.constEnd()) {
    if (i.value() == name) {
      return i.key();
    }
    ++i;
  }
  return -1;
}
QHash<int, QByteArray> UsersSearch::roleNames() const {
  QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
  names.insert(Qt::UserRole + 0, "color");
  names.insert(Qt::UserRole + 1, "matched");
  names.insert(Qt::UserRole + 2, "name");
  names.insert(Qt::UserRole + 3, "profilePicture");
  names.insert(Qt::UserRole + 4, "selected");
  names.insert(Qt::UserRole + 5, "userId");
  return names;
}

QVariant UsersSearch::headerData(int section, Qt::Orientation orientation,
                                 int role) const {
  if (orientation != Qt::Horizontal) {
    return QVariant();
  }
  return m_headerData.value(
      qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
      role == Qt::DisplayRole ? QString::number(section + 1) : QVariant());
}

bool UsersSearch::setHeaderData(int section, Qt::Orientation orientation,
                                const QVariant &value, int role) {
  if (orientation != Qt::Horizontal) {
    return false;
  }
  m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)),
                      value);
  return true;
}

bool UsersSearch::setData(const QModelIndex &index, const QVariant &value,
                          int role) {
  if (index.column() == 0) {
    if (role == Qt::UserRole + 4) {
      if (value.canConvert(qMetaTypeId<bool>())) {
        return setSelected(index.row(), value.value<bool>());
      }
    }
  }
  return false;
}

extern "C" {
UsersSearch::Private *users_search_new(UsersSearchPtrBundle *);
void users_search_free(UsersSearch::Private *);
void users_search_filter_get(const UsersSearch::Private *, QString *,
                             qstring_set);
void users_search_filter_set(UsersSearch::Private *, const ushort *str,
                             int len);
void users_search_filter_set_none(UsersSearch::Private *);
void users_search_clear_filter(UsersSearch::Private *);
void users_search_refresh(UsersSearch::Private *);
}
extern "C" {
Utils::Private *utils_new(UtilsPtrBundle *);
void utils_free(Utils::Private *);
bool utils_compare_byte_array(const Utils::Private *, const char *, int,
                              const char *, int);
void utils_image_dimensions(const Utils::Private *, const ushort *, int,
                            QString *, qstring_set);
bool utils_is_valid_rand_id(const Utils::Private *, const char *, int);
bool utils_save_file(const Utils::Private *, const ushort *, int,
                     const ushort *, int);
void utils_strip_url_prefix(const Utils::Private *, const ushort *, int,
                            QString *, qstring_set);
}

Config::Config(bool /*owned*/, QObject *parent)
    : QObject(parent), m_d(nullptr), m_ownsPrivate(false) {}

Config::Config(QObject *parent)
    : QObject(parent),
      m_d(config_new(new ConfigPtrBundle{
          this, configColorChanged, configColorschemeChanged,
          configConfigIdChanged, configNameChanged,
          configNtsConversationIdChanged, configPreferredExpirationChanged,
          configProfilePictureChanged})),
      m_ownsPrivate(true) {}

Config::~Config() {
  if (m_ownsPrivate) {
    config_free(m_d);
  }
}

quint32 Config::color() const { return config_color_get(m_d); }
void Config::setColor(quint32 v) { config_color_set(m_d, v); }

quint32 Config::colorscheme() const { return config_colorscheme_get(m_d); }
void Config::setColorscheme(quint32 v) { config_colorscheme_set(m_d, v); }

QString Config::configId() const {
  QString v;
  config_config_id_get(m_d, &v, set_qstring);
  return v;
}

QString Config::name() const {
  QString v;
  config_name_get(m_d, &v, set_qstring);
  return v;
}
void Config::setName(const QString &v) {
  config_name_set(m_d, reinterpret_cast<const ushort *>(v.data()), v.size());
}

QByteArray Config::ntsConversationId() const {
  QByteArray v;
  config_nts_conversation_id_get(m_d, &v, set_qbytearray);
  return v;
}

quint8 Config::preferredExpiration() const {
  return config_preferred_expiration_get(m_d);
}
void Config::setPreferredExpiration(quint8 v) {
  config_preferred_expiration_set(m_d, v);
}

QString Config::profilePicture() const {
  QString v;
  config_profile_picture_get(m_d, &v, set_qstring);
  return v;
}
void Config::setProfilePicture(const QString &profile_picture) {
  return config_set_profile_picture(m_d, profile_picture.utf16(),
                                    profile_picture.size());
}

ConversationBuilder::ConversationBuilder(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

ConversationBuilder::ConversationBuilder(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(conversation_builder_new(new ConversationBuilderPtrBundle{
          this, conversationBuilderPictureChanged,
          [](const ConversationBuilder *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](ConversationBuilder *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](ConversationBuilder *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](ConversationBuilder *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](ConversationBuilder *o) { o->beginResetModel(); },
          [](ConversationBuilder *o) { o->endResetModel(); },
          [](ConversationBuilder *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](ConversationBuilder *o) { o->endInsertRows(); },
          [](ConversationBuilder *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](ConversationBuilder *o) { o->endMoveRows(); },
          [](ConversationBuilder *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](ConversationBuilder *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &ConversationBuilder::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

ConversationBuilder::~ConversationBuilder() {
  if (m_ownsPrivate) {
    conversation_builder_free(m_d);
  }
}
void ConversationBuilder::initHeaderData() {}

QString ConversationBuilder::picture() const {
  QString v;
  conversation_builder_picture_get(m_d, &v, set_qstring);
  return v;
}
bool ConversationBuilder::addMember(const QString &user_id) {
  return conversation_builder_add_member(m_d, user_id.utf16(), user_id.size());
}
void ConversationBuilder::clear() { return conversation_builder_clear(m_d); }
void ConversationBuilder::finalize() {
  return conversation_builder_finalize(m_d);
}
void ConversationBuilder::removeLast() {
  return conversation_builder_remove_last(m_d);
}
bool ConversationBuilder::removeMemberById(const QString &user_id) {
  return conversation_builder_remove_member_by_id(m_d, user_id.utf16(),
                                                  user_id.size());
}
bool ConversationBuilder::removeMemberByIndex(quint64 index) {
  return conversation_builder_remove_member_by_index(m_d, index);
}
void ConversationBuilder::setProfilePicture(const QString &profile_picture) {
  return conversation_builder_set_profile_picture(m_d, profile_picture.utf16(),
                                                  profile_picture.size());
}
void ConversationBuilder::setTitle(const QString &title) {
  return conversation_builder_set_title(m_d, title.utf16(), title.size());
}

ConversationContent::ConversationContent(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_members(new Members(false, this)),
      m_messages(new Messages(false, this)), m_d(nullptr),
      m_ownsPrivate(false) {
  initHeaderData();
}

ConversationContent::ConversationContent(QObject *parent)
    : QAbstractItemModel(parent), m_members(new Members(false, this)),
      m_messages(new Messages(false, this)),
      m_d(conversation_content_new(new ConversationContentPtrBundle{
          this,
          conversationContentConversationIdChanged,
          m_members,
          membersFilterChanged,
          membersFilterRegexChanged,
          [](const Members *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Members *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Members *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Members *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Members *o) { o->beginResetModel(); },
          [](Members *o) { o->endResetModel(); },
          [](Members *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Members *o) { o->endInsertRows(); },
          [](Members *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Members *o) { o->endMoveRows(); },
          [](Members *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Members *o) { o->endRemoveRows(); },
          m_messages,
          m_messages->m_builder,
          messageBuilderBodyChanged,
          m_messages->m_builder->m_documentAttachments,
          [](const DocumentAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](DocumentAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](DocumentAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](DocumentAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](DocumentAttachments *o) { o->beginResetModel(); },
          [](DocumentAttachments *o) { o->endResetModel(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endInsertRows(); },
          [](DocumentAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](DocumentAttachments *o) { o->endMoveRows(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endRemoveRows(); },
          messageBuilderHasDocAttachmentChanged,
          messageBuilderHasMediaAttachmentChanged,
          messageBuilderIsReplyChanged,
          m_messages->m_builder->m_mediaAttachments,
          [](const MediaAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](MediaAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MediaAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MediaAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MediaAttachments *o) { o->beginResetModel(); },
          [](MediaAttachments *o) { o->endResetModel(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endInsertRows(); },
          [](MediaAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MediaAttachments *o) { o->endMoveRows(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endRemoveRows(); },
          messageBuilderOpAuthorChanged,
          messageBuilderOpBodyChanged,
          messageBuilderOpDocAttachmentsChanged,
          messageBuilderOpExpirationTimeChanged,
          messageBuilderOpIdChanged,
          messageBuilderOpMediaAttachmentsChanged,
          messageBuilderOpTimeChanged,
          [](const MessageBuilder *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](MessageBuilder *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MessageBuilder *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MessageBuilder *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MessageBuilder *o) { o->beginResetModel(); },
          [](MessageBuilder *o) { o->endResetModel(); },
          [](MessageBuilder *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MessageBuilder *o) { o->endInsertRows(); },
          [](MessageBuilder *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MessageBuilder *o) { o->endMoveRows(); },
          [](MessageBuilder *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MessageBuilder *o) { o->endRemoveRows(); },
          messagesIsEmptyChanged,
          messagesLastAuthorChanged,
          messagesLastBodyChanged,
          messagesLastStatusChanged,
          messagesLastTimeChanged,
          messagesSearchActiveChanged,
          messagesSearchIndexChanged,
          messagesSearchNumMatchesChanged,
          messagesSearchPatternChanged,
          messagesSearchRegexChanged,
          [](const Messages *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Messages *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Messages *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Messages *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Messages *o) { o->beginResetModel(); },
          [](Messages *o) { o->endResetModel(); },
          [](Messages *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Messages *o) { o->endInsertRows(); },
          [](Messages *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Messages *o) { o->endMoveRows(); },
          [](Messages *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Messages *o) { o->endRemoveRows(); },
          [](const ConversationContent *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](ConversationContent *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](ConversationContent *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](ConversationContent *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](ConversationContent *o) { o->beginResetModel(); },
          [](ConversationContent *o) { o->endResetModel(); },
          [](ConversationContent *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](ConversationContent *o) { o->endInsertRows(); },
          [](ConversationContent *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](ConversationContent *o) { o->endMoveRows(); },
          [](ConversationContent *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](ConversationContent *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  m_members->m_d = conversation_content_members_get(m_d);
  m_messages->m_d = conversation_content_messages_get(m_d);
  m_messages->m_builder->m_d = messages_builder_get(m_messages->m_d);
  m_messages->m_builder->m_documentAttachments->m_d =
      message_builder_document_attachments_get(m_messages->m_builder->m_d);
  m_messages->m_builder->m_mediaAttachments->m_d =
      message_builder_media_attachments_get(m_messages->m_builder->m_d);
  connect(
      this->m_members, &Members::newDataReady, this->m_members,
      [this](const QModelIndex &i) { this->m_members->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this->m_messages->m_builder->m_documentAttachments,
      &DocumentAttachments::newDataReady,
      this->m_messages->m_builder->m_documentAttachments,
      [this](const QModelIndex &i) {
        this->m_messages->m_builder->m_documentAttachments->fetchMore(i);
      },
      Qt::QueuedConnection);
  connect(
      this->m_messages->m_builder->m_mediaAttachments,
      &MediaAttachments::newDataReady,
      this->m_messages->m_builder->m_mediaAttachments,
      [this](const QModelIndex &i) {
        this->m_messages->m_builder->m_mediaAttachments->fetchMore(i);
      },
      Qt::QueuedConnection);
  connect(
      this->m_messages->m_builder, &MessageBuilder::newDataReady,
      this->m_messages->m_builder,
      [this](const QModelIndex &i) {
        this->m_messages->m_builder->fetchMore(i);
      },
      Qt::QueuedConnection);
  connect(
      this->m_messages, &Messages::newDataReady, this->m_messages,
      [this](const QModelIndex &i) { this->m_messages->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this, &ConversationContent::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

ConversationContent::~ConversationContent() {
  if (m_ownsPrivate) {
    conversation_content_free(m_d);
  }
}
void ConversationContent::initHeaderData() {}

QByteArray ConversationContent::conversationId() const {
  QByteArray v;
  conversation_content_conversation_id_get(m_d, &v, set_qbytearray);
  return v;
}
void ConversationContent::setConversationId(const QByteArray &v) {
  if (v.isNull()) {
    conversation_content_conversation_id_set_none(m_d);
  } else {
    conversation_content_conversation_id_set(m_d, v.data(), v.size());
  }
}

const Members *ConversationContent::members() const { return m_members; }
Members *ConversationContent::members() { return m_members; }

const Messages *ConversationContent::messages() const { return m_messages; }
Messages *ConversationContent::messages() { return m_messages; }

Conversations::Conversations(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

Conversations::Conversations(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(conversations_new(new ConversationsPtrBundle{
          this, conversationsFilterChanged, conversationsFilterRegexChanged,
          [](const Conversations *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Conversations *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Conversations *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Conversations *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Conversations *o) { o->beginResetModel(); },
          [](Conversations *o) { o->endResetModel(); },
          [](Conversations *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Conversations *o) { o->endInsertRows(); },
          [](Conversations *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Conversations *o) { o->endMoveRows(); },
          [](Conversations *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Conversations *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &Conversations::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

Conversations::~Conversations() {
  if (m_ownsPrivate) {
    conversations_free(m_d);
  }
}
void Conversations::initHeaderData() {}

QString Conversations::filter() const {
  QString v;
  conversations_filter_get(m_d, &v, set_qstring);
  return v;
}
void Conversations::setFilter(const QString &v) {
  conversations_filter_set(m_d, reinterpret_cast<const ushort *>(v.data()),
                           v.size());
}

bool Conversations::filterRegex() const {
  return conversations_filter_regex_get(m_d);
}
void Conversations::setFilterRegex(bool v) {
  conversations_filter_regex_set(m_d, v);
}
void Conversations::clearFilter() { return conversations_clear_filter(m_d); }
qint64 Conversations::indexById(const QByteArray &conversation_id) const {
  return conversations_index_by_id(m_d, conversation_id.data(),
                                   conversation_id.size());
}
bool Conversations::removeConversation(quint64 row_index) {
  return conversations_remove_conversation(m_d, row_index);
}
void Conversations::setProfilePicture(quint64 index,
                                      const QString &profile_picture) {
  return conversations_set_profile_picture(m_d, index, profile_picture.utf16(),
                                           profile_picture.size());
}
bool Conversations::toggleFilterRegex() {
  return conversations_toggle_filter_regex(m_d);
}

DocumentAttachments::DocumentAttachments(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

DocumentAttachments::DocumentAttachments(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(document_attachments_new(new DocumentAttachmentsPtrBundle{
          this,
          [](const DocumentAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](DocumentAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](DocumentAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](DocumentAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](DocumentAttachments *o) { o->beginResetModel(); },
          [](DocumentAttachments *o) { o->endResetModel(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endInsertRows(); },
          [](DocumentAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](DocumentAttachments *o) { o->endMoveRows(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &DocumentAttachments::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

DocumentAttachments::~DocumentAttachments() {
  if (m_ownsPrivate) {
    document_attachments_free(m_d);
  }
}
void DocumentAttachments::initHeaderData() {}

EmojiPicker::EmojiPicker(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

EmojiPicker::EmojiPicker(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(emoji_picker_new(new EmojiPickerPtrBundle{
          this,
          emojiPickerActivities_indexChanged,
          emojiPickerBody_indexChanged,
          emojiPickerFlags_indexChanged,
          emojiPickerFood_indexChanged,
          emojiPickerLocations_indexChanged,
          emojiPickerNature_indexChanged,
          emojiPickerObjects_indexChanged,
          emojiPickerSmileys_indexChanged,
          emojiPickerSymbols_indexChanged,
          [](const EmojiPicker *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](EmojiPicker *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](EmojiPicker *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](EmojiPicker *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](EmojiPicker *o) { o->beginResetModel(); },
          [](EmojiPicker *o) { o->endResetModel(); },
          [](EmojiPicker *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](EmojiPicker *o) { o->endInsertRows(); },
          [](EmojiPicker *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](EmojiPicker *o) { o->endMoveRows(); },
          [](EmojiPicker *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](EmojiPicker *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &EmojiPicker::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

EmojiPicker::~EmojiPicker() {
  if (m_ownsPrivate) {
    emoji_picker_free(m_d);
  }
}
void EmojiPicker::initHeaderData() {}

quint32 EmojiPicker::activities_index() const {
  return emoji_picker_activities_index_get(m_d);
}

quint32 EmojiPicker::body_index() const {
  return emoji_picker_body_index_get(m_d);
}

quint32 EmojiPicker::flags_index() const {
  return emoji_picker_flags_index_get(m_d);
}

quint32 EmojiPicker::food_index() const {
  return emoji_picker_food_index_get(m_d);
}

quint32 EmojiPicker::locations_index() const {
  return emoji_picker_locations_index_get(m_d);
}

quint32 EmojiPicker::nature_index() const {
  return emoji_picker_nature_index_get(m_d);
}

quint32 EmojiPicker::objects_index() const {
  return emoji_picker_objects_index_get(m_d);
}

quint32 EmojiPicker::smileys_index() const {
  return emoji_picker_smileys_index_get(m_d);
}

quint32 EmojiPicker::symbols_index() const {
  return emoji_picker_symbols_index_get(m_d);
}
void EmojiPicker::clearSearch() { return emoji_picker_clear_search(m_d); }
void EmojiPicker::setSearchString(const QString &search_string) {
  return emoji_picker_set_search_string(m_d, search_string.utf16(),
                                        search_string.size());
}

Errors::Errors(bool /*owned*/, QObject *parent)
    : QObject(parent), m_d(nullptr), m_ownsPrivate(false) {}

Errors::Errors(QObject *parent)
    : QObject(parent),
      m_d(errors_new(new ErrorsPtrBundle{this, errorsTryPollChanged})),
      m_ownsPrivate(true) {}

Errors::~Errors() {
  if (m_ownsPrivate) {
    errors_free(m_d);
  }
}

bool Errors::tryPoll() const { return errors_try_poll_get(m_d); }
QString Errors::nextError() {
  QString s;
  errors_next_error(m_d, &s, set_qstring);
  return s;
}

Herald::Herald(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_config(new Config(false, this)),
      m_conversationBuilder(new ConversationBuilder(false, this)),
      m_conversations(new Conversations(false, this)),
      m_errors(new Errors(false, this)),
      m_messageSearch(new MessageSearch(false, this)),
      m_users(new Users(false, this)),
      m_usersSearch(new UsersSearch(false, this)),
      m_utils(new Utils(false, this)), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

Herald::Herald(QObject *parent)
    : QAbstractItemModel(parent), m_config(new Config(false, this)),
      m_conversationBuilder(new ConversationBuilder(false, this)),
      m_conversations(new Conversations(false, this)),
      m_errors(new Errors(false, this)),
      m_messageSearch(new MessageSearch(false, this)),
      m_users(new Users(false, this)),
      m_usersSearch(new UsersSearch(false, this)),
      m_utils(new Utils(false, this)),
      m_d(herald_new(new HeraldPtrBundle{
          this,
          m_config,
          configColorChanged,
          configColorschemeChanged,
          configConfigIdChanged,
          configNameChanged,
          configNtsConversationIdChanged,
          configPreferredExpirationChanged,
          configProfilePictureChanged,
          heraldConfigInitChanged,
          heraldConnectionPendingChanged,
          heraldConnectionUpChanged,
          m_conversationBuilder,
          conversationBuilderPictureChanged,
          [](const ConversationBuilder *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](ConversationBuilder *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](ConversationBuilder *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](ConversationBuilder *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](ConversationBuilder *o) { o->beginResetModel(); },
          [](ConversationBuilder *o) { o->endResetModel(); },
          [](ConversationBuilder *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](ConversationBuilder *o) { o->endInsertRows(); },
          [](ConversationBuilder *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](ConversationBuilder *o) { o->endMoveRows(); },
          [](ConversationBuilder *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](ConversationBuilder *o) { o->endRemoveRows(); },
          m_conversations,
          conversationsFilterChanged,
          conversationsFilterRegexChanged,
          [](const Conversations *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Conversations *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Conversations *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Conversations *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Conversations *o) { o->beginResetModel(); },
          [](Conversations *o) { o->endResetModel(); },
          [](Conversations *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Conversations *o) { o->endInsertRows(); },
          [](Conversations *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Conversations *o) { o->endMoveRows(); },
          [](Conversations *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Conversations *o) { o->endRemoveRows(); },
          m_errors,
          errorsTryPollChanged,
          m_messageSearch,
          messageSearchRegexSearchChanged,
          messageSearchSearchPatternChanged,
          [](const MessageSearch *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](MessageSearch *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MessageSearch *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MessageSearch *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MessageSearch *o) { o->beginResetModel(); },
          [](MessageSearch *o) { o->endResetModel(); },
          [](MessageSearch *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MessageSearch *o) { o->endInsertRows(); },
          [](MessageSearch *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MessageSearch *o) { o->endMoveRows(); },
          [](MessageSearch *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MessageSearch *o) { o->endRemoveRows(); },
          heraldRegistrationFailureCodeChanged,
          m_users,
          usersFilterChanged,
          usersFilterRegexChanged,
          [](const Users *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Users *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Users *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Users *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Users *o) { o->beginResetModel(); },
          [](Users *o) { o->endResetModel(); },
          [](Users *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Users *o) { o->endInsertRows(); },
          [](Users *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Users *o) { o->endMoveRows(); },
          [](Users *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Users *o) { o->endRemoveRows(); },
          m_usersSearch,
          usersSearchFilterChanged,
          [](const UsersSearch *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](UsersSearch *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](UsersSearch *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](UsersSearch *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](UsersSearch *o) { o->beginResetModel(); },
          [](UsersSearch *o) { o->endResetModel(); },
          [](UsersSearch *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](UsersSearch *o) { o->endInsertRows(); },
          [](UsersSearch *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](UsersSearch *o) { o->endMoveRows(); },
          [](UsersSearch *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](UsersSearch *o) { o->endRemoveRows(); },
          m_utils,
          [](const Herald *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Herald *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Herald *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Herald *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Herald *o) { o->beginResetModel(); },
          [](Herald *o) { o->endResetModel(); },
          [](Herald *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Herald *o) { o->endInsertRows(); },
          [](Herald *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Herald *o) { o->endMoveRows(); },
          [](Herald *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Herald *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  m_config->m_d = herald_config_get(m_d);
  m_conversationBuilder->m_d = herald_conversation_builder_get(m_d);
  m_conversations->m_d = herald_conversations_get(m_d);
  m_errors->m_d = herald_errors_get(m_d);
  m_messageSearch->m_d = herald_message_search_get(m_d);
  m_users->m_d = herald_users_get(m_d);
  m_usersSearch->m_d = herald_users_search_get(m_d);
  m_utils->m_d = herald_utils_get(m_d);
  connect(
      this->m_conversationBuilder, &ConversationBuilder::newDataReady,
      this->m_conversationBuilder,
      [this](const QModelIndex &i) {
        this->m_conversationBuilder->fetchMore(i);
      },
      Qt::QueuedConnection);
  connect(
      this->m_conversations, &Conversations::newDataReady,
      this->m_conversations,
      [this](const QModelIndex &i) { this->m_conversations->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this->m_messageSearch, &MessageSearch::newDataReady,
      this->m_messageSearch,
      [this](const QModelIndex &i) { this->m_messageSearch->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this->m_users, &Users::newDataReady, this->m_users,
      [this](const QModelIndex &i) { this->m_users->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this->m_usersSearch, &UsersSearch::newDataReady, this->m_usersSearch,
      [this](const QModelIndex &i) { this->m_usersSearch->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this, &Herald::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

Herald::~Herald() {
  if (m_ownsPrivate) {
    herald_free(m_d);
  }
}
void Herald::initHeaderData() {}

const Config *Herald::config() const { return m_config; }
Config *Herald::config() { return m_config; }

bool Herald::configInit() const { return herald_config_init_get(m_d); }

bool Herald::connectionPending() const {
  return herald_connection_pending_get(m_d);
}

bool Herald::connectionUp() const { return herald_connection_up_get(m_d); }

const ConversationBuilder *Herald::conversationBuilder() const {
  return m_conversationBuilder;
}
ConversationBuilder *Herald::conversationBuilder() {
  return m_conversationBuilder;
}

const Conversations *Herald::conversations() const { return m_conversations; }
Conversations *Herald::conversations() { return m_conversations; }

const Errors *Herald::errors() const { return m_errors; }
Errors *Herald::errors() { return m_errors; }

const MessageSearch *Herald::messageSearch() const { return m_messageSearch; }
MessageSearch *Herald::messageSearch() { return m_messageSearch; }

QVariant Herald::registrationFailureCode() const {
  QVariant v;
  auto r = herald_registration_failure_code_get(m_d);
  if (r.some) {
    v.setValue(r.value);
  }
  return r;
}

const Users *Herald::users() const { return m_users; }
Users *Herald::users() { return m_users; }

const UsersSearch *Herald::usersSearch() const { return m_usersSearch; }
UsersSearch *Herald::usersSearch() { return m_usersSearch; }

const Utils *Herald::utils() const { return m_utils; }
Utils *Herald::utils() { return m_utils; }
bool Herald::login() { return herald_login(m_d); }
void Herald::registerNewUser(const QString &user_id, const QString &addr,
                             const QString &port) {
  return herald_register_new_user(m_d, user_id.utf16(), user_id.size(),
                                  addr.utf16(), addr.size(), port.utf16(),
                                  port.size());
}
void Herald::setAppLocalDataDir(const QString &path) {
  return herald_set_app_local_data_dir(m_d, path.utf16(), path.size());
}

MediaAttachments::MediaAttachments(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

MediaAttachments::MediaAttachments(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(media_attachments_new(new MediaAttachmentsPtrBundle{
          this,
          [](const MediaAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](MediaAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MediaAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MediaAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MediaAttachments *o) { o->beginResetModel(); },
          [](MediaAttachments *o) { o->endResetModel(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endInsertRows(); },
          [](MediaAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MediaAttachments *o) { o->endMoveRows(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &MediaAttachments::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

MediaAttachments::~MediaAttachments() {
  if (m_ownsPrivate) {
    media_attachments_free(m_d);
  }
}
void MediaAttachments::initHeaderData() {}

Members::Members(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

Members::Members(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(members_new(new MembersPtrBundle{
          this, membersFilterChanged, membersFilterRegexChanged,
          [](const Members *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Members *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Members *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Members *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Members *o) { o->beginResetModel(); },
          [](Members *o) { o->endResetModel(); },
          [](Members *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Members *o) { o->endInsertRows(); },
          [](Members *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Members *o) { o->endMoveRows(); },
          [](Members *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Members *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &Members::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

Members::~Members() {
  if (m_ownsPrivate) {
    members_free(m_d);
  }
}
void Members::initHeaderData() {}

QString Members::filter() const {
  QString v;
  members_filter_get(m_d, &v, set_qstring);
  return v;
}
void Members::setFilter(const QString &v) {
  members_filter_set(m_d, reinterpret_cast<const ushort *>(v.data()), v.size());
}

bool Members::filterRegex() const { return members_filter_regex_get(m_d); }
void Members::setFilterRegex(bool v) { members_filter_regex_set(m_d, v); }
bool Members::addToConversation(const QString &id) {
  return members_add_to_conversation(m_d, id.utf16(), id.size());
}
bool Members::removeFromConversationByIndex(quint64 row_index) {
  return members_remove_from_conversation_by_index(m_d, row_index);
}
bool Members::toggleFilterRegex() { return members_toggle_filter_regex(m_d); }

MessageBuilder::MessageBuilder(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent),
      m_documentAttachments(new DocumentAttachments(false, this)),
      m_mediaAttachments(new MediaAttachments(false, this)), m_d(nullptr),
      m_ownsPrivate(false) {
  initHeaderData();
}

MessageBuilder::MessageBuilder(QObject *parent)
    : QAbstractItemModel(parent),
      m_documentAttachments(new DocumentAttachments(false, this)),
      m_mediaAttachments(new MediaAttachments(false, this)),
      m_d(message_builder_new(new MessageBuilderPtrBundle{
          this,
          messageBuilderBodyChanged,
          m_documentAttachments,
          [](const DocumentAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](DocumentAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](DocumentAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](DocumentAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](DocumentAttachments *o) { o->beginResetModel(); },
          [](DocumentAttachments *o) { o->endResetModel(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endInsertRows(); },
          [](DocumentAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](DocumentAttachments *o) { o->endMoveRows(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endRemoveRows(); },
          messageBuilderHasDocAttachmentChanged,
          messageBuilderHasMediaAttachmentChanged,
          messageBuilderIsReplyChanged,
          m_mediaAttachments,
          [](const MediaAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](MediaAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MediaAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MediaAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MediaAttachments *o) { o->beginResetModel(); },
          [](MediaAttachments *o) { o->endResetModel(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endInsertRows(); },
          [](MediaAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MediaAttachments *o) { o->endMoveRows(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endRemoveRows(); },
          messageBuilderOpAuthorChanged,
          messageBuilderOpBodyChanged,
          messageBuilderOpDocAttachmentsChanged,
          messageBuilderOpExpirationTimeChanged,
          messageBuilderOpIdChanged,
          messageBuilderOpMediaAttachmentsChanged,
          messageBuilderOpTimeChanged,
          [](const MessageBuilder *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](MessageBuilder *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MessageBuilder *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MessageBuilder *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MessageBuilder *o) { o->beginResetModel(); },
          [](MessageBuilder *o) { o->endResetModel(); },
          [](MessageBuilder *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MessageBuilder *o) { o->endInsertRows(); },
          [](MessageBuilder *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MessageBuilder *o) { o->endMoveRows(); },
          [](MessageBuilder *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MessageBuilder *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  m_documentAttachments->m_d = message_builder_document_attachments_get(m_d);
  m_mediaAttachments->m_d = message_builder_media_attachments_get(m_d);
  connect(
      this->m_documentAttachments, &DocumentAttachments::newDataReady,
      this->m_documentAttachments,
      [this](const QModelIndex &i) {
        this->m_documentAttachments->fetchMore(i);
      },
      Qt::QueuedConnection);
  connect(
      this->m_mediaAttachments, &MediaAttachments::newDataReady,
      this->m_mediaAttachments,
      [this](const QModelIndex &i) { this->m_mediaAttachments->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this, &MessageBuilder::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

MessageBuilder::~MessageBuilder() {
  if (m_ownsPrivate) {
    message_builder_free(m_d);
  }
}
void MessageBuilder::initHeaderData() {}

QString MessageBuilder::body() const {
  QString v;
  message_builder_body_get(m_d, &v, set_qstring);
  return v;
}
void MessageBuilder::setBody(const QString &v) {
  if (v.isNull()) {
    message_builder_body_set_none(m_d);
  } else {
    message_builder_body_set(m_d, reinterpret_cast<const ushort *>(v.data()),
                             v.size());
  }
}

const DocumentAttachments *MessageBuilder::documentAttachments() const {
  return m_documentAttachments;
}
DocumentAttachments *MessageBuilder::documentAttachments() {
  return m_documentAttachments;
}

bool MessageBuilder::hasDocAttachment() const {
  return message_builder_has_doc_attachment_get(m_d);
}

bool MessageBuilder::hasMediaAttachment() const {
  return message_builder_has_media_attachment_get(m_d);
}

bool MessageBuilder::isReply() const {
  return message_builder_is_reply_get(m_d);
}

const MediaAttachments *MessageBuilder::mediaAttachments() const {
  return m_mediaAttachments;
}
MediaAttachments *MessageBuilder::mediaAttachments() {
  return m_mediaAttachments;
}

QString MessageBuilder::opAuthor() const {
  QString v;
  message_builder_op_author_get(m_d, &v, set_qstring);
  return v;
}

QString MessageBuilder::opBody() const {
  QString v;
  message_builder_op_body_get(m_d, &v, set_qstring);
  return v;
}

QString MessageBuilder::opDocAttachments() const {
  QString v;
  message_builder_op_doc_attachments_get(m_d, &v, set_qstring);
  return v;
}

QVariant MessageBuilder::opExpirationTime() const {
  QVariant v;
  auto r = message_builder_op_expiration_time_get(m_d);
  if (r.some) {
    v.setValue(r.value);
  }
  return r;
}

QByteArray MessageBuilder::opId() const {
  QByteArray v;
  message_builder_op_id_get(m_d, &v, set_qbytearray);
  return v;
}
void MessageBuilder::setOpId(const QByteArray &v) {
  if (v.isNull()) {
    message_builder_op_id_set_none(m_d);
  } else {
    message_builder_op_id_set(m_d, v.data(), v.size());
  }
}

QString MessageBuilder::opMediaAttachments() const {
  QString v;
  message_builder_op_media_attachments_get(m_d, &v, set_qstring);
  return v;
}

QVariant MessageBuilder::opTime() const {
  QVariant v;
  auto r = message_builder_op_time_get(m_d);
  if (r.some) {
    v.setValue(r.value);
  }
  return r;
}
bool MessageBuilder::addAttachment(const QString &path) {
  return message_builder_add_attachment(m_d, path.utf16(), path.size());
}
void MessageBuilder::clearReply() { return message_builder_clear_reply(m_d); }
void MessageBuilder::finalize() { return message_builder_finalize(m_d); }
bool MessageBuilder::removeDoc(quint64 row_index) {
  return message_builder_remove_doc(m_d, row_index);
}
bool MessageBuilder::removeMedia(quint64 row_index) {
  return message_builder_remove_media(m_d, row_index);
}

MessageSearch::MessageSearch(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

MessageSearch::MessageSearch(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(message_search_new(new MessageSearchPtrBundle{
          this, messageSearchRegexSearchChanged,
          messageSearchSearchPatternChanged,
          [](const MessageSearch *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](MessageSearch *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MessageSearch *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MessageSearch *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MessageSearch *o) { o->beginResetModel(); },
          [](MessageSearch *o) { o->endResetModel(); },
          [](MessageSearch *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MessageSearch *o) { o->endInsertRows(); },
          [](MessageSearch *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MessageSearch *o) { o->endMoveRows(); },
          [](MessageSearch *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MessageSearch *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &MessageSearch::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

MessageSearch::~MessageSearch() {
  if (m_ownsPrivate) {
    message_search_free(m_d);
  }
}
void MessageSearch::initHeaderData() {}

QVariant MessageSearch::regexSearch() const {
  QVariant v;
  auto r = message_search_regex_search_get(m_d);
  if (r.some) {
    v.setValue(r.value);
  }
  return r;
}
void MessageSearch::setRegexSearch(const QVariant &v) {
  if (v.isNull() || !v.canConvert<bool>()) {
    message_search_regex_search_set_none(m_d);
  } else {
    message_search_regex_search_set(m_d, v.value<bool>());
  }
}

QString MessageSearch::searchPattern() const {
  QString v;
  message_search_search_pattern_get(m_d, &v, set_qstring);
  return v;
}
void MessageSearch::setSearchPattern(const QString &v) {
  if (v.isNull()) {
    message_search_search_pattern_set_none(m_d);
  } else {
    message_search_search_pattern_set(
        m_d, reinterpret_cast<const ushort *>(v.data()), v.size());
  }
}
void MessageSearch::clearSearch() { return message_search_clear_search(m_d); }

Messages::Messages(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_builder(new MessageBuilder(false, this)),
      m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

Messages::Messages(QObject *parent)
    : QAbstractItemModel(parent), m_builder(new MessageBuilder(false, this)),
      m_d(messages_new(new MessagesPtrBundle{
          this,
          m_builder,
          messageBuilderBodyChanged,
          m_builder->m_documentAttachments,
          [](const DocumentAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](DocumentAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](DocumentAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](DocumentAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](DocumentAttachments *o) { o->beginResetModel(); },
          [](DocumentAttachments *o) { o->endResetModel(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endInsertRows(); },
          [](DocumentAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](DocumentAttachments *o) { o->endMoveRows(); },
          [](DocumentAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](DocumentAttachments *o) { o->endRemoveRows(); },
          messageBuilderHasDocAttachmentChanged,
          messageBuilderHasMediaAttachmentChanged,
          messageBuilderIsReplyChanged,
          m_builder->m_mediaAttachments,
          [](const MediaAttachments *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](MediaAttachments *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MediaAttachments *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MediaAttachments *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MediaAttachments *o) { o->beginResetModel(); },
          [](MediaAttachments *o) { o->endResetModel(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endInsertRows(); },
          [](MediaAttachments *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MediaAttachments *o) { o->endMoveRows(); },
          [](MediaAttachments *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MediaAttachments *o) { o->endRemoveRows(); },
          messageBuilderOpAuthorChanged,
          messageBuilderOpBodyChanged,
          messageBuilderOpDocAttachmentsChanged,
          messageBuilderOpExpirationTimeChanged,
          messageBuilderOpIdChanged,
          messageBuilderOpMediaAttachmentsChanged,
          messageBuilderOpTimeChanged,
          [](const MessageBuilder *o) {
            Q_EMIT o->newDataReady(QModelIndex());
          },
          [](MessageBuilder *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](MessageBuilder *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](MessageBuilder *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](MessageBuilder *o) { o->beginResetModel(); },
          [](MessageBuilder *o) { o->endResetModel(); },
          [](MessageBuilder *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](MessageBuilder *o) { o->endInsertRows(); },
          [](MessageBuilder *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](MessageBuilder *o) { o->endMoveRows(); },
          [](MessageBuilder *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](MessageBuilder *o) { o->endRemoveRows(); },
          messagesIsEmptyChanged,
          messagesLastAuthorChanged,
          messagesLastBodyChanged,
          messagesLastStatusChanged,
          messagesLastTimeChanged,
          messagesSearchActiveChanged,
          messagesSearchIndexChanged,
          messagesSearchNumMatchesChanged,
          messagesSearchPatternChanged,
          messagesSearchRegexChanged,
          [](const Messages *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Messages *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Messages *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Messages *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Messages *o) { o->beginResetModel(); },
          [](Messages *o) { o->endResetModel(); },
          [](Messages *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Messages *o) { o->endInsertRows(); },
          [](Messages *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Messages *o) { o->endMoveRows(); },
          [](Messages *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Messages *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  m_builder->m_d = messages_builder_get(m_d);
  m_builder->m_documentAttachments->m_d =
      message_builder_document_attachments_get(m_builder->m_d);
  m_builder->m_mediaAttachments->m_d =
      message_builder_media_attachments_get(m_builder->m_d);
  connect(
      this->m_builder->m_documentAttachments,
      &DocumentAttachments::newDataReady,
      this->m_builder->m_documentAttachments,
      [this](const QModelIndex &i) {
        this->m_builder->m_documentAttachments->fetchMore(i);
      },
      Qt::QueuedConnection);
  connect(
      this->m_builder->m_mediaAttachments, &MediaAttachments::newDataReady,
      this->m_builder->m_mediaAttachments,
      [this](const QModelIndex &i) {
        this->m_builder->m_mediaAttachments->fetchMore(i);
      },
      Qt::QueuedConnection);
  connect(
      this->m_builder, &MessageBuilder::newDataReady, this->m_builder,
      [this](const QModelIndex &i) { this->m_builder->fetchMore(i); },
      Qt::QueuedConnection);
  connect(
      this, &Messages::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

Messages::~Messages() {
  if (m_ownsPrivate) {
    messages_free(m_d);
  }
}
void Messages::initHeaderData() {}

const MessageBuilder *Messages::builder() const { return m_builder; }
MessageBuilder *Messages::builder() { return m_builder; }

bool Messages::isEmpty() const { return messages_is_empty_get(m_d); }

QString Messages::lastAuthor() const {
  QString v;
  messages_last_author_get(m_d, &v, set_qstring);
  return v;
}

QString Messages::lastBody() const {
  QString v;
  messages_last_body_get(m_d, &v, set_qstring);
  return v;
}

QVariant Messages::lastStatus() const {
  QVariant v;
  auto r = messages_last_status_get(m_d);
  if (r.some) {
    v.setValue(r.value);
  }
  return r;
}

QVariant Messages::lastTime() const {
  QVariant v;
  auto r = messages_last_time_get(m_d);
  if (r.some) {
    v.setValue(r.value);
  }
  return r;
}

bool Messages::searchActive() const { return messages_search_active_get(m_d); }
void Messages::setSearchActive(bool v) { messages_search_active_set(m_d, v); }

quint64 Messages::searchIndex() const { return messages_search_index_get(m_d); }

quint64 Messages::searchNumMatches() const {
  return messages_search_num_matches_get(m_d);
}

QString Messages::searchPattern() const {
  QString v;
  messages_search_pattern_get(m_d, &v, set_qstring);
  return v;
}
void Messages::setSearchPattern(const QString &v) {
  messages_search_pattern_set(m_d, reinterpret_cast<const ushort *>(v.data()),
                              v.size());
}

bool Messages::searchRegex() const { return messages_search_regex_get(m_d); }
void Messages::setSearchRegex(bool v) { messages_search_regex_set(m_d, v); }
void Messages::addReaction(quint64 index, const QString &content) {
  return messages_add_reaction(m_d, index, content.utf16(), content.size());
}
bool Messages::clearConversationHistory() {
  return messages_clear_conversation_history(m_d);
}
void Messages::clearSearch() { return messages_clear_search(m_d); }
bool Messages::deleteMessage(quint64 row_index) {
  return messages_delete_message(m_d, row_index);
}
qint64 Messages::indexById(const QByteArray &msg_id) const {
  return messages_index_by_id(m_d, msg_id.data(), msg_id.size());
}
void Messages::markRead(quint64 index) {
  return messages_mark_read(m_d, index);
}
qint64 Messages::nextSearchMatch() { return messages_next_search_match(m_d); }
qint64 Messages::prevSearchMatch() { return messages_prev_search_match(m_d); }
void Messages::removeReaction(quint64 index, const QString &content) {
  return messages_remove_reaction(m_d, index, content.utf16(), content.size());
}
bool Messages::saveAllAttachments(quint64 index, const QString &dest) const {
  return messages_save_all_attachments(m_d, index, dest.utf16(), dest.size());
}
void Messages::setElisionCharCount(quint16 char_count) {
  return messages_set_elision_char_count(m_d, char_count);
}
void Messages::setElisionCharsPerLine(quint8 chars_per_line) {
  return messages_set_elision_chars_per_line(m_d, chars_per_line);
}
void Messages::setElisionLineCount(quint8 line_count) {
  return messages_set_elision_line_count(m_d, line_count);
}
void Messages::setSearchHint(float scrollbar_position, float scrollbar_height) {
  return messages_set_search_hint(m_d, scrollbar_position, scrollbar_height);
}

Users::Users(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

Users::Users(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(users_new(new UsersPtrBundle{
          this, usersFilterChanged, usersFilterRegexChanged,
          [](const Users *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](Users *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](Users *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](Users *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](Users *o) { o->beginResetModel(); },
          [](Users *o) { o->endResetModel(); },
          [](Users *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](Users *o) { o->endInsertRows(); },
          [](Users *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](Users *o) { o->endMoveRows(); },
          [](Users *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](Users *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &Users::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

Users::~Users() {
  if (m_ownsPrivate) {
    users_free(m_d);
  }
}
void Users::initHeaderData() {}

QString Users::filter() const {
  QString v;
  users_filter_get(m_d, &v, set_qstring);
  return v;
}
void Users::setFilter(const QString &v) {
  users_filter_set(m_d, reinterpret_cast<const ushort *>(v.data()), v.size());
}

bool Users::filterRegex() const { return users_filter_regex_get(m_d); }
void Users::setFilterRegex(bool v) { users_filter_regex_set(m_d, v); }
QByteArray Users::add(const QString &id) {
  QByteArray s;
  users_add(m_d, id.utf16(), id.size(), &s, set_qbytearray);
  return s;
}
void Users::clearFilter() { return users_clear_filter(m_d); }
quint32 Users::colorById(const QString &id) const {
  return users_color_by_id(m_d, id.utf16(), id.size());
}
QString Users::nameById(const QString &id) const {
  QString s;
  users_name_by_id(m_d, id.utf16(), id.size(), &s, set_qstring);
  return s;
}
QString Users::profilePictureById(const QString &id) const {
  QString s;
  users_profile_picture_by_id(m_d, id.utf16(), id.size(), &s, set_qstring);
  return s;
}
void Users::setProfilePicture(quint64 index, const QString &profile_picture) {
  return users_set_profile_picture(m_d, index, profile_picture.utf16(),
                                   profile_picture.size());
}
bool Users::toggleFilterRegex() { return users_toggle_filter_regex(m_d); }

UsersSearch::UsersSearch(bool /*owned*/, QObject *parent)
    : QAbstractItemModel(parent), m_d(nullptr), m_ownsPrivate(false) {
  initHeaderData();
}

UsersSearch::UsersSearch(QObject *parent)
    : QAbstractItemModel(parent),
      m_d(users_search_new(new UsersSearchPtrBundle{
          this, usersSearchFilterChanged,
          [](const UsersSearch *o) { Q_EMIT o->newDataReady(QModelIndex()); },
          [](UsersSearch *o) { Q_EMIT o->layoutAboutToBeChanged(); },
          [](UsersSearch *o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
          },
          [](UsersSearch *o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                           o->createIndex(last, 0, last));
          },
          [](UsersSearch *o) { o->beginResetModel(); },
          [](UsersSearch *o) { o->endResetModel(); },
          [](UsersSearch *o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
          },
          [](UsersSearch *o) { o->endInsertRows(); },
          [](UsersSearch *o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(),
                             destination);
          },
          [](UsersSearch *o) { o->endMoveRows(); },
          [](UsersSearch *o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
          },
          [](UsersSearch *o) { o->endRemoveRows(); }})),
      m_ownsPrivate(true) {
  connect(
      this, &UsersSearch::newDataReady, this,
      [this](const QModelIndex &i) { this->fetchMore(i); },
      Qt::QueuedConnection);
  initHeaderData();
}

UsersSearch::~UsersSearch() {
  if (m_ownsPrivate) {
    users_search_free(m_d);
  }
}
void UsersSearch::initHeaderData() {}

QString UsersSearch::filter() const {
  QString v;
  users_search_filter_get(m_d, &v, set_qstring);
  return v;
}
void UsersSearch::setFilter(const QString &v) {
  if (v.isNull()) {
    users_search_filter_set_none(m_d);
  } else {
    users_search_filter_set(m_d, reinterpret_cast<const ushort *>(v.data()),
                            v.size());
  }
}
void UsersSearch::clearFilter() { return users_search_clear_filter(m_d); }
void UsersSearch::refresh() { return users_search_refresh(m_d); }

Utils::Utils(bool /*owned*/, QObject *parent)
    : QObject(parent), m_d(nullptr), m_ownsPrivate(false) {}

Utils::Utils(QObject *parent)
    : QObject(parent), m_d(utils_new(new UtilsPtrBundle{this})),
      m_ownsPrivate(true) {}

Utils::~Utils() {
  if (m_ownsPrivate) {
    utils_free(m_d);
  }
}
bool Utils::compareByteArray(const QByteArray &bs1,
                             const QByteArray &bs2) const {
  return utils_compare_byte_array(m_d, bs1.data(), bs1.size(), bs2.data(),
                                  bs2.size());
}
QString Utils::imageDimensions(const QString &path) const {
  QString s;
  utils_image_dimensions(m_d, path.utf16(), path.size(), &s, set_qstring);
  return s;
}
bool Utils::isValidRandId(const QByteArray &bs) const {
  return utils_is_valid_rand_id(m_d, bs.data(), bs.size());
}
bool Utils::saveFile(const QString &fpath, const QString &target_path) const {
  return utils_save_file(m_d, fpath.utf16(), fpath.size(), target_path.utf16(),
                         target_path.size());
}
QString Utils::stripUrlPrefix(const QString &path) const {
  QString s;
  utils_strip_url_prefix(m_d, path.utf16(), path.size(), &s, set_qstring);
  return s;
}
