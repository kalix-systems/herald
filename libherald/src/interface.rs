/* generated by rust_qt_binding_generator */
use riqtshaw_types::*;

use crate::imp::*;

pub struct AttachmentsQObject {}

pub struct AttachmentsEmitter {
    qobject: Arc<AtomicPtr<AttachmentsQObject>>,
    attachments_msg_id_changed: fn(*mut AttachmentsQObject),
    new_data_ready: fn(*mut AttachmentsQObject),
}

impl AttachmentsEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> AttachmentsEmitter {
        AttachmentsEmitter {
            qobject: self.qobject.clone(),
            attachments_msg_id_changed: self.attachments_msg_id_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const AttachmentsQObject = null();
        self.qobject
            .store(n as *mut AttachmentsQObject, Ordering::SeqCst);
    }
    pub fn attachments_msg_id_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.attachments_msg_id_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct AttachmentsList {
    qobject: *mut AttachmentsQObject,
    layout_about_to_be_changed: fn(*mut AttachmentsQObject),
    layout_changed: fn(*mut AttachmentsQObject),
    data_changed: fn(*mut AttachmentsQObject, usize, usize),
    begin_reset_model: fn(*mut AttachmentsQObject),
    end_reset_model: fn(*mut AttachmentsQObject),
    begin_insert_rows: fn(*mut AttachmentsQObject, usize, usize),
    end_insert_rows: fn(*mut AttachmentsQObject),
    begin_move_rows: fn(*mut AttachmentsQObject, usize, usize, usize),
    end_move_rows: fn(*mut AttachmentsQObject),
    begin_remove_rows: fn(*mut AttachmentsQObject, usize, usize),
    end_remove_rows: fn(*mut AttachmentsQObject),
}

impl AttachmentsList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait AttachmentsTrait {
    fn new(
        emit: AttachmentsEmitter,
        model: AttachmentsList,
    ) -> Self;
    fn emit(&mut self) -> &mut AttachmentsEmitter;
    fn attachments_msg_id(&self) -> Option<&[u8]>;
    fn set_attachments_msg_id(
        &mut self,
        value: Option<&[u8]>,
    );
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn attachment_path(
        &self,
        index: usize,
    ) -> &str;
}

#[no_mangle]
pub extern "C" fn attachments_new(
    attachments: *mut AttachmentsQObject,
    attachments_attachments_msg_id_changed: fn(*mut AttachmentsQObject),
    attachments_new_data_ready: fn(*mut AttachmentsQObject),
    attachments_layout_about_to_be_changed: fn(*mut AttachmentsQObject),
    attachments_layout_changed: fn(*mut AttachmentsQObject),
    attachments_data_changed: fn(*mut AttachmentsQObject, usize, usize),
    attachments_begin_reset_model: fn(*mut AttachmentsQObject),
    attachments_end_reset_model: fn(*mut AttachmentsQObject),
    attachments_begin_insert_rows: fn(*mut AttachmentsQObject, usize, usize),
    attachments_end_insert_rows: fn(*mut AttachmentsQObject),
    attachments_begin_move_rows: fn(*mut AttachmentsQObject, usize, usize, usize),
    attachments_end_move_rows: fn(*mut AttachmentsQObject),
    attachments_begin_remove_rows: fn(*mut AttachmentsQObject, usize, usize),
    attachments_end_remove_rows: fn(*mut AttachmentsQObject),
) -> *mut Attachments {
    let attachments_emit = AttachmentsEmitter {
        qobject: Arc::new(AtomicPtr::new(attachments)),
        attachments_msg_id_changed: attachments_attachments_msg_id_changed,
        new_data_ready: attachments_new_data_ready,
    };
    let model = AttachmentsList {
        qobject: attachments,
        layout_about_to_be_changed: attachments_layout_about_to_be_changed,
        layout_changed: attachments_layout_changed,
        data_changed: attachments_data_changed,
        begin_reset_model: attachments_begin_reset_model,
        end_reset_model: attachments_end_reset_model,
        begin_insert_rows: attachments_begin_insert_rows,
        end_insert_rows: attachments_end_insert_rows,
        begin_move_rows: attachments_begin_move_rows,
        end_move_rows: attachments_end_move_rows,
        begin_remove_rows: attachments_begin_remove_rows,
        end_remove_rows: attachments_end_remove_rows,
    };
    let d_attachments = Attachments::new(attachments_emit, model);
    Box::into_raw(Box::new(d_attachments))
}

#[no_mangle]
pub unsafe extern "C" fn attachments_free(ptr: *mut Attachments) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn attachments_attachments_msg_id_get(
    ptr: *const Attachments,
    p: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.attachments_msg_id();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn attachments_attachments_msg_id_set(
    ptr: *mut Attachments,
    v: *const c_char,
    len: c_int,
) {
    let o = &mut *ptr;
    let v = qba_slice!(v, len);
    o.set_attachments_msg_id(Some(v.into()));
}

#[no_mangle]
pub unsafe extern "C" fn attachments_attachments_msg_id_set_none(ptr: *mut Attachments) {
    let o = &mut *ptr;
    o.set_attachments_msg_id(None);
}

#[no_mangle]
pub unsafe extern "C" fn attachments_row_count(ptr: *const Attachments) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn attachments_insert_rows(
    ptr: *mut Attachments,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn attachments_remove_rows(
    ptr: *mut Attachments,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn attachments_can_fetch_more(ptr: *const Attachments) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn attachments_fetch_more(ptr: *mut Attachments) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn attachments_sort(
    ptr: *mut Attachments,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn attachments_data_attachment_path(
    ptr: *const Attachments,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.attachment_path(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

pub struct ConfigQObject {}

pub struct ConfigEmitter {
    qobject: Arc<AtomicPtr<ConfigQObject>>,
    color_changed: fn(*mut ConfigQObject),
    colorscheme_changed: fn(*mut ConfigQObject),
    config_id_changed: fn(*mut ConfigQObject),
    name_changed: fn(*mut ConfigQObject),
    nts_conversation_id_changed: fn(*mut ConfigQObject),
    profile_picture_changed: fn(*mut ConfigQObject),
}

impl ConfigEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> ConfigEmitter {
        ConfigEmitter {
            qobject: self.qobject.clone(),
            color_changed: self.color_changed,
            colorscheme_changed: self.colorscheme_changed,
            config_id_changed: self.config_id_changed,
            name_changed: self.name_changed,
            nts_conversation_id_changed: self.nts_conversation_id_changed,
            profile_picture_changed: self.profile_picture_changed,
        }
    }
    fn clear(&self) {
        let n: *const ConfigQObject = null();
        self.qobject
            .store(n as *mut ConfigQObject, Ordering::SeqCst);
    }
    pub fn color_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.color_changed)(ptr);
        }
    }
    pub fn colorscheme_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.colorscheme_changed)(ptr);
        }
    }
    pub fn config_id_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.config_id_changed)(ptr);
        }
    }
    pub fn name_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.name_changed)(ptr);
        }
    }
    pub fn nts_conversation_id_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.nts_conversation_id_changed)(ptr);
        }
    }
    pub fn profile_picture_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.profile_picture_changed)(ptr);
        }
    }
}

pub trait ConfigTrait {
    fn new(emit: ConfigEmitter) -> Self;
    fn emit(&mut self) -> &mut ConfigEmitter;
    fn color(&self) -> u32;
    fn set_color(
        &mut self,
        value: u32,
    );
    fn colorscheme(&self) -> u32;
    fn set_colorscheme(
        &mut self,
        value: u32,
    );
    fn config_id(&self) -> &str;
    fn name(&self) -> &str;
    fn set_name(
        &mut self,
        value: String,
    );
    fn nts_conversation_id(&self) -> &[u8];
    fn profile_picture(&self) -> Option<&str>;
    fn set_profile_picture(
        &mut self,
        value: Option<String>,
    );
}

#[no_mangle]
pub extern "C" fn config_new(
    config: *mut ConfigQObject,
    config_color_changed: fn(*mut ConfigQObject),
    config_colorscheme_changed: fn(*mut ConfigQObject),
    config_config_id_changed: fn(*mut ConfigQObject),
    config_name_changed: fn(*mut ConfigQObject),
    config_nts_conversation_id_changed: fn(*mut ConfigQObject),
    config_profile_picture_changed: fn(*mut ConfigQObject),
) -> *mut Config {
    let config_emit = ConfigEmitter {
        qobject: Arc::new(AtomicPtr::new(config)),
        color_changed: config_color_changed,
        colorscheme_changed: config_colorscheme_changed,
        config_id_changed: config_config_id_changed,
        name_changed: config_name_changed,
        nts_conversation_id_changed: config_nts_conversation_id_changed,
        profile_picture_changed: config_profile_picture_changed,
    };
    let d_config = Config::new(config_emit);
    Box::into_raw(Box::new(d_config))
}

#[no_mangle]
pub unsafe extern "C" fn config_free(ptr: *mut Config) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn config_color_get(ptr: *const Config) -> u32 {
    (&*ptr).color()
}

#[no_mangle]
pub unsafe extern "C" fn config_color_set(
    ptr: *mut Config,
    v: u32,
) {
    (&mut *ptr).set_color(v);
}

#[no_mangle]
pub unsafe extern "C" fn config_colorscheme_get(ptr: *const Config) -> u32 {
    (&*ptr).colorscheme()
}

#[no_mangle]
pub unsafe extern "C" fn config_colorscheme_set(
    ptr: *mut Config,
    v: u32,
) {
    (&mut *ptr).set_colorscheme(v);
}

#[no_mangle]
pub unsafe extern "C" fn config_config_id_get(
    ptr: *const Config,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.config_id();
    let s: *const c_char = v.as_ptr() as (*const c_char);
    set(p, s, to_c_int(v.len()));
}

#[no_mangle]
pub unsafe extern "C" fn config_name_get(
    ptr: *const Config,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.name();
    let s: *const c_char = v.as_ptr() as (*const c_char);
    set(p, s, to_c_int(v.len()));
}

#[no_mangle]
pub unsafe extern "C" fn config_name_set(
    ptr: *mut Config,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_name(s);
}

#[no_mangle]
pub unsafe extern "C" fn config_nts_conversation_id_get(
    ptr: *const Config,
    p: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.nts_conversation_id();
    let s: *const c_char = v.as_ptr() as (*const c_char);
    set(p, s, to_c_int(v.len()));
}

#[no_mangle]
pub unsafe extern "C" fn config_profile_picture_get(
    ptr: *const Config,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.profile_picture();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn config_profile_picture_set(
    ptr: *mut Config,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_profile_picture(Some(s));
}

#[no_mangle]
pub unsafe extern "C" fn config_profile_picture_set_none(ptr: *mut Config) {
    let o = &mut *ptr;
    o.set_profile_picture(None);
}

pub struct ConversationBuilderQObject {}

pub struct ConversationBuilderEmitter {
    qobject: Arc<AtomicPtr<ConversationBuilderQObject>>,
    picture_changed: fn(*mut ConversationBuilderQObject),
    new_data_ready: fn(*mut ConversationBuilderQObject),
}

impl ConversationBuilderEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> ConversationBuilderEmitter {
        ConversationBuilderEmitter {
            qobject: self.qobject.clone(),
            picture_changed: self.picture_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const ConversationBuilderQObject = null();
        self.qobject
            .store(n as *mut ConversationBuilderQObject, Ordering::SeqCst);
    }
    pub fn picture_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.picture_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct ConversationBuilderList {
    qobject: *mut ConversationBuilderQObject,
    layout_about_to_be_changed: fn(*mut ConversationBuilderQObject),
    layout_changed: fn(*mut ConversationBuilderQObject),
    data_changed: fn(*mut ConversationBuilderQObject, usize, usize),
    begin_reset_model: fn(*mut ConversationBuilderQObject),
    end_reset_model: fn(*mut ConversationBuilderQObject),
    begin_insert_rows: fn(*mut ConversationBuilderQObject, usize, usize),
    end_insert_rows: fn(*mut ConversationBuilderQObject),
    begin_move_rows: fn(*mut ConversationBuilderQObject, usize, usize, usize),
    end_move_rows: fn(*mut ConversationBuilderQObject),
    begin_remove_rows: fn(*mut ConversationBuilderQObject, usize, usize),
    end_remove_rows: fn(*mut ConversationBuilderQObject),
}

impl ConversationBuilderList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait ConversationBuilderTrait {
    fn new(
        emit: ConversationBuilderEmitter,
        model: ConversationBuilderList,
    ) -> Self;
    fn emit(&mut self) -> &mut ConversationBuilderEmitter;
    fn picture(&self) -> Option<&str>;
    fn set_picture(
        &mut self,
        value: Option<String>,
    );
    fn add_member(
        &mut self,
        user_id: String,
    ) -> bool;
    fn clear(&mut self) -> ();
    fn finalize(&mut self) -> ();
    fn remove_last(&mut self) -> ();
    fn remove_member_by_id(
        &mut self,
        user_id: String,
    ) -> bool;
    fn remove_member_by_index(
        &mut self,
        index: u64,
    ) -> bool;
    fn set_title(
        &mut self,
        title: String,
    ) -> ();
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn member_id(
        &self,
        index: usize,
    ) -> &str;
}

#[no_mangle]
pub extern "C" fn conversation_builder_new(
    conversation_builder: *mut ConversationBuilderQObject,
    conversation_builder_picture_changed: fn(*mut ConversationBuilderQObject),
    conversation_builder_new_data_ready: fn(*mut ConversationBuilderQObject),
    conversation_builder_layout_about_to_be_changed: fn(*mut ConversationBuilderQObject),
    conversation_builder_layout_changed: fn(*mut ConversationBuilderQObject),
    conversation_builder_data_changed: fn(*mut ConversationBuilderQObject, usize, usize),
    conversation_builder_begin_reset_model: fn(*mut ConversationBuilderQObject),
    conversation_builder_end_reset_model: fn(*mut ConversationBuilderQObject),
    conversation_builder_begin_insert_rows: fn(*mut ConversationBuilderQObject, usize, usize),
    conversation_builder_end_insert_rows: fn(*mut ConversationBuilderQObject),
    conversation_builder_begin_move_rows: fn(*mut ConversationBuilderQObject, usize, usize, usize),
    conversation_builder_end_move_rows: fn(*mut ConversationBuilderQObject),
    conversation_builder_begin_remove_rows: fn(*mut ConversationBuilderQObject, usize, usize),
    conversation_builder_end_remove_rows: fn(*mut ConversationBuilderQObject),
) -> *mut ConversationBuilder {
    let conversation_builder_emit = ConversationBuilderEmitter {
        qobject: Arc::new(AtomicPtr::new(conversation_builder)),
        picture_changed: conversation_builder_picture_changed,
        new_data_ready: conversation_builder_new_data_ready,
    };
    let model = ConversationBuilderList {
        qobject: conversation_builder,
        layout_about_to_be_changed: conversation_builder_layout_about_to_be_changed,
        layout_changed: conversation_builder_layout_changed,
        data_changed: conversation_builder_data_changed,
        begin_reset_model: conversation_builder_begin_reset_model,
        end_reset_model: conversation_builder_end_reset_model,
        begin_insert_rows: conversation_builder_begin_insert_rows,
        end_insert_rows: conversation_builder_end_insert_rows,
        begin_move_rows: conversation_builder_begin_move_rows,
        end_move_rows: conversation_builder_end_move_rows,
        begin_remove_rows: conversation_builder_begin_remove_rows,
        end_remove_rows: conversation_builder_end_remove_rows,
    };
    let d_conversation_builder = ConversationBuilder::new(conversation_builder_emit, model);
    Box::into_raw(Box::new(d_conversation_builder))
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_free(ptr: *mut ConversationBuilder) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_picture_get(
    ptr: *const ConversationBuilder,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.picture();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_picture_set(
    ptr: *mut ConversationBuilder,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_picture(Some(s));
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_picture_set_none(ptr: *mut ConversationBuilder) {
    let o = &mut *ptr;
    o.set_picture(None);
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_add_member(
    ptr: *mut ConversationBuilder,
    user_id_str: *const c_ushort,
    user_id_len: c_int,
) -> bool {
    let mut user_id = String::new();
    set_string_from_utf16(&mut user_id, user_id_str, user_id_len);
    let o = &mut *ptr;
    o.add_member(user_id)
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_clear(ptr: *mut ConversationBuilder) {
    let o = &mut *ptr;
    o.clear()
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_finalize(ptr: *mut ConversationBuilder) {
    let o = &mut *ptr;
    o.finalize()
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_remove_last(ptr: *mut ConversationBuilder) {
    let o = &mut *ptr;
    o.remove_last()
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_remove_member_by_id(
    ptr: *mut ConversationBuilder,
    user_id_str: *const c_ushort,
    user_id_len: c_int,
) -> bool {
    let mut user_id = String::new();
    set_string_from_utf16(&mut user_id, user_id_str, user_id_len);
    let o = &mut *ptr;
    o.remove_member_by_id(user_id)
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_remove_member_by_index(
    ptr: *mut ConversationBuilder,
    index: u64,
) -> bool {
    let o = &mut *ptr;
    o.remove_member_by_index(index)
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_set_title(
    ptr: *mut ConversationBuilder,
    title_str: *const c_ushort,
    title_len: c_int,
) {
    let mut title = String::new();
    set_string_from_utf16(&mut title, title_str, title_len);
    let o = &mut *ptr;
    o.set_title(title)
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_row_count(ptr: *const ConversationBuilder) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_insert_rows(
    ptr: *mut ConversationBuilder,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_remove_rows(
    ptr: *mut ConversationBuilder,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_can_fetch_more(
    ptr: *const ConversationBuilder
) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_fetch_more(ptr: *mut ConversationBuilder) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_sort(
    ptr: *mut ConversationBuilder,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn conversation_builder_data_member_id(
    ptr: *const ConversationBuilder,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.member_id(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

pub struct ConversationsQObject {}

pub struct ConversationsEmitter {
    qobject: Arc<AtomicPtr<ConversationsQObject>>,
    filter_changed: fn(*mut ConversationsQObject),
    filter_regex_changed: fn(*mut ConversationsQObject),
    new_data_ready: fn(*mut ConversationsQObject),
}

impl ConversationsEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> ConversationsEmitter {
        ConversationsEmitter {
            qobject: self.qobject.clone(),
            filter_changed: self.filter_changed,
            filter_regex_changed: self.filter_regex_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const ConversationsQObject = null();
        self.qobject
            .store(n as *mut ConversationsQObject, Ordering::SeqCst);
    }
    pub fn filter_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.filter_changed)(ptr);
        }
    }
    pub fn filter_regex_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.filter_regex_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct ConversationsList {
    qobject: *mut ConversationsQObject,
    layout_about_to_be_changed: fn(*mut ConversationsQObject),
    layout_changed: fn(*mut ConversationsQObject),
    data_changed: fn(*mut ConversationsQObject, usize, usize),
    begin_reset_model: fn(*mut ConversationsQObject),
    end_reset_model: fn(*mut ConversationsQObject),
    begin_insert_rows: fn(*mut ConversationsQObject, usize, usize),
    end_insert_rows: fn(*mut ConversationsQObject),
    begin_move_rows: fn(*mut ConversationsQObject, usize, usize, usize),
    end_move_rows: fn(*mut ConversationsQObject),
    begin_remove_rows: fn(*mut ConversationsQObject, usize, usize),
    end_remove_rows: fn(*mut ConversationsQObject),
}

impl ConversationsList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait ConversationsTrait {
    fn new(
        emit: ConversationsEmitter,
        model: ConversationsList,
    ) -> Self;
    fn emit(&mut self) -> &mut ConversationsEmitter;
    fn filter(&self) -> &str;
    fn set_filter(
        &mut self,
        value: String,
    );
    fn filter_regex(&self) -> bool;
    fn set_filter_regex(
        &mut self,
        value: bool,
    );
    fn clear_filter(&mut self) -> ();
    fn remove_conversation(
        &mut self,
        row_index: u64,
    ) -> bool;
    fn toggle_filter_regex(&mut self) -> bool;
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn color(
        &self,
        index: usize,
    ) -> u32;
    fn set_color(
        &mut self,
        index: usize,
        _: u32,
    ) -> bool;
    fn conversation_id(
        &self,
        index: usize,
    ) -> Vec<u8>;
    fn expiration_period(
        &self,
        index: usize,
    ) -> u8;
    fn set_expiration_period(
        &mut self,
        index: usize,
        _: u8,
    ) -> bool;
    fn matched(
        &self,
        index: usize,
    ) -> bool;
    fn muted(
        &self,
        index: usize,
    ) -> bool;
    fn set_muted(
        &mut self,
        index: usize,
        _: bool,
    ) -> bool;
    fn pairwise(
        &self,
        index: usize,
    ) -> bool;
    fn picture(
        &self,
        index: usize,
    ) -> Option<String>;
    fn set_picture(
        &mut self,
        index: usize,
        _: Option<String>,
    ) -> bool;
    fn title(
        &self,
        index: usize,
    ) -> Option<String>;
    fn set_title(
        &mut self,
        index: usize,
        _: Option<String>,
    ) -> bool;
}

#[no_mangle]
pub extern "C" fn conversations_new(
    conversations: *mut ConversationsQObject,
    conversations_filter_changed: fn(*mut ConversationsQObject),
    conversations_filter_regex_changed: fn(*mut ConversationsQObject),
    conversations_new_data_ready: fn(*mut ConversationsQObject),
    conversations_layout_about_to_be_changed: fn(*mut ConversationsQObject),
    conversations_layout_changed: fn(*mut ConversationsQObject),
    conversations_data_changed: fn(*mut ConversationsQObject, usize, usize),
    conversations_begin_reset_model: fn(*mut ConversationsQObject),
    conversations_end_reset_model: fn(*mut ConversationsQObject),
    conversations_begin_insert_rows: fn(*mut ConversationsQObject, usize, usize),
    conversations_end_insert_rows: fn(*mut ConversationsQObject),
    conversations_begin_move_rows: fn(*mut ConversationsQObject, usize, usize, usize),
    conversations_end_move_rows: fn(*mut ConversationsQObject),
    conversations_begin_remove_rows: fn(*mut ConversationsQObject, usize, usize),
    conversations_end_remove_rows: fn(*mut ConversationsQObject),
) -> *mut Conversations {
    let conversations_emit = ConversationsEmitter {
        qobject: Arc::new(AtomicPtr::new(conversations)),
        filter_changed: conversations_filter_changed,
        filter_regex_changed: conversations_filter_regex_changed,
        new_data_ready: conversations_new_data_ready,
    };
    let model = ConversationsList {
        qobject: conversations,
        layout_about_to_be_changed: conversations_layout_about_to_be_changed,
        layout_changed: conversations_layout_changed,
        data_changed: conversations_data_changed,
        begin_reset_model: conversations_begin_reset_model,
        end_reset_model: conversations_end_reset_model,
        begin_insert_rows: conversations_begin_insert_rows,
        end_insert_rows: conversations_end_insert_rows,
        begin_move_rows: conversations_begin_move_rows,
        end_move_rows: conversations_end_move_rows,
        begin_remove_rows: conversations_begin_remove_rows,
        end_remove_rows: conversations_end_remove_rows,
    };
    let d_conversations = Conversations::new(conversations_emit, model);
    Box::into_raw(Box::new(d_conversations))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_free(ptr: *mut Conversations) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn conversations_filter_get(
    ptr: *const Conversations,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.filter();
    let s: *const c_char = v.as_ptr() as (*const c_char);
    set(p, s, to_c_int(v.len()));
}

#[no_mangle]
pub unsafe extern "C" fn conversations_filter_set(
    ptr: *mut Conversations,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_filter(s);
}

#[no_mangle]
pub unsafe extern "C" fn conversations_filter_regex_get(ptr: *const Conversations) -> bool {
    (&*ptr).filter_regex()
}

#[no_mangle]
pub unsafe extern "C" fn conversations_filter_regex_set(
    ptr: *mut Conversations,
    v: bool,
) {
    (&mut *ptr).set_filter_regex(v);
}

#[no_mangle]
pub unsafe extern "C" fn conversations_clear_filter(ptr: *mut Conversations) {
    let o = &mut *ptr;
    o.clear_filter()
}

#[no_mangle]
pub unsafe extern "C" fn conversations_remove_conversation(
    ptr: *mut Conversations,
    row_index: u64,
) -> bool {
    let o = &mut *ptr;
    o.remove_conversation(row_index)
}

#[no_mangle]
pub unsafe extern "C" fn conversations_toggle_filter_regex(ptr: *mut Conversations) -> bool {
    let o = &mut *ptr;
    o.toggle_filter_regex()
}

#[no_mangle]
pub unsafe extern "C" fn conversations_row_count(ptr: *const Conversations) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn conversations_insert_rows(
    ptr: *mut Conversations,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn conversations_remove_rows(
    ptr: *mut Conversations,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn conversations_can_fetch_more(ptr: *const Conversations) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn conversations_fetch_more(ptr: *mut Conversations) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn conversations_sort(
    ptr: *mut Conversations,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_color(
    ptr: *const Conversations,
    row: c_int,
) -> u32 {
    let o = &*ptr;
    o.color(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_set_data_color(
    ptr: *mut Conversations,
    row: c_int,
    v: u32,
) -> bool {
    (&mut *ptr).set_color(to_usize(row).unwrap_or(0), v)
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_conversation_id(
    ptr: *const Conversations,
    row: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.conversation_id(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_expiration_period(
    ptr: *const Conversations,
    row: c_int,
) -> u8 {
    let o = &*ptr;
    o.expiration_period(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_set_data_expiration_period(
    ptr: *mut Conversations,
    row: c_int,
    v: u8,
) -> bool {
    (&mut *ptr).set_expiration_period(to_usize(row).unwrap_or(0), v)
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_matched(
    ptr: *const Conversations,
    row: c_int,
) -> bool {
    let o = &*ptr;
    o.matched(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_muted(
    ptr: *const Conversations,
    row: c_int,
) -> bool {
    let o = &*ptr;
    o.muted(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_set_data_muted(
    ptr: *mut Conversations,
    row: c_int,
    v: bool,
) -> bool {
    (&mut *ptr).set_muted(to_usize(row).unwrap_or(0), v)
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_pairwise(
    ptr: *const Conversations,
    row: c_int,
) -> bool {
    let o = &*ptr;
    o.pairwise(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_picture(
    ptr: *const Conversations,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.picture(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn conversations_set_data_picture(
    ptr: *mut Conversations,
    row: c_int,
    s: *const c_ushort,
    len: c_int,
) -> bool {
    let o = &mut *ptr;
    let mut v = String::new();
    set_string_from_utf16(&mut v, s, len);
    o.set_picture(to_usize(row).unwrap_or(0), Some(v))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_set_data_picture_none(
    ptr: *mut Conversations,
    row: c_int,
) -> bool {
    (&mut *ptr).set_picture(to_usize(row).unwrap_or(0), None)
}

#[no_mangle]
pub unsafe extern "C" fn conversations_data_title(
    ptr: *const Conversations,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.title(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn conversations_set_data_title(
    ptr: *mut Conversations,
    row: c_int,
    s: *const c_ushort,
    len: c_int,
) -> bool {
    let o = &mut *ptr;
    let mut v = String::new();
    set_string_from_utf16(&mut v, s, len);
    o.set_title(to_usize(row).unwrap_or(0), Some(v))
}

#[no_mangle]
pub unsafe extern "C" fn conversations_set_data_title_none(
    ptr: *mut Conversations,
    row: c_int,
) -> bool {
    (&mut *ptr).set_title(to_usize(row).unwrap_or(0), None)
}

pub struct ErrorsQObject {}

pub struct ErrorsEmitter {
    qobject: Arc<AtomicPtr<ErrorsQObject>>,
    try_poll_changed: fn(*mut ErrorsQObject),
}

impl ErrorsEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> ErrorsEmitter {
        ErrorsEmitter {
            qobject: self.qobject.clone(),
            try_poll_changed: self.try_poll_changed,
        }
    }
    fn clear(&self) {
        let n: *const ErrorsQObject = null();
        self.qobject
            .store(n as *mut ErrorsQObject, Ordering::SeqCst);
    }
    pub fn try_poll_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.try_poll_changed)(ptr);
        }
    }
}

pub trait ErrorsTrait {
    fn new(emit: ErrorsEmitter) -> Self;
    fn emit(&mut self) -> &mut ErrorsEmitter;
    fn try_poll(&self) -> u8;
    fn next_error(&mut self) -> String;
}

#[no_mangle]
pub extern "C" fn errors_new(
    errors: *mut ErrorsQObject,
    errors_try_poll_changed: fn(*mut ErrorsQObject),
) -> *mut Errors {
    let errors_emit = ErrorsEmitter {
        qobject: Arc::new(AtomicPtr::new(errors)),
        try_poll_changed: errors_try_poll_changed,
    };
    let d_errors = Errors::new(errors_emit);
    Box::into_raw(Box::new(d_errors))
}

#[no_mangle]
pub unsafe extern "C" fn errors_free(ptr: *mut Errors) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn errors_try_poll_get(ptr: *const Errors) -> u8 {
    (&*ptr).try_poll()
}

#[no_mangle]
pub unsafe extern "C" fn errors_next_error(
    ptr: *mut Errors,
    d: *mut QString,
    set: fn(*mut QString, str: *const c_char, len: c_int),
) {
    let o = &mut *ptr;
    let r = o.next_error();
    let s: *const c_char = r.as_ptr() as (*const c_char);
    set(d, s, r.len() as i32);
}

pub struct HeraldQObject {}

pub struct HeraldEmitter {
    qobject: Arc<AtomicPtr<HeraldQObject>>,
    config_init_changed: fn(*mut HeraldQObject),
    connection_pending_changed: fn(*mut HeraldQObject),
    connection_up_changed: fn(*mut HeraldQObject),
    new_data_ready: fn(*mut HeraldQObject),
}

impl HeraldEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> HeraldEmitter {
        HeraldEmitter {
            qobject: self.qobject.clone(),
            config_init_changed: self.config_init_changed,
            connection_pending_changed: self.connection_pending_changed,
            connection_up_changed: self.connection_up_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const HeraldQObject = null();
        self.qobject
            .store(n as *mut HeraldQObject, Ordering::SeqCst);
    }
    pub fn config_init_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.config_init_changed)(ptr);
        }
    }
    pub fn connection_pending_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.connection_pending_changed)(ptr);
        }
    }
    pub fn connection_up_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.connection_up_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct HeraldList {
    qobject: *mut HeraldQObject,
    layout_about_to_be_changed: fn(*mut HeraldQObject),
    layout_changed: fn(*mut HeraldQObject),
    data_changed: fn(*mut HeraldQObject, usize, usize),
    begin_reset_model: fn(*mut HeraldQObject),
    end_reset_model: fn(*mut HeraldQObject),
    begin_insert_rows: fn(*mut HeraldQObject, usize, usize),
    end_insert_rows: fn(*mut HeraldQObject),
    begin_move_rows: fn(*mut HeraldQObject, usize, usize, usize),
    end_move_rows: fn(*mut HeraldQObject),
    begin_remove_rows: fn(*mut HeraldQObject, usize, usize),
    end_remove_rows: fn(*mut HeraldQObject),
}

impl HeraldList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait HeraldTrait {
    fn new(
        emit: HeraldEmitter,
        model: HeraldList,
        config: Config,
        conversation_builder: ConversationBuilder,
        conversations: Conversations,
        errors: Errors,
        message_search: MessageSearch,
        users: Users,
        users_search: UsersSearch,
        utils: Utils,
    ) -> Self;
    fn emit(&mut self) -> &mut HeraldEmitter;
    fn config(&self) -> &Config;
    fn config_mut(&mut self) -> &mut Config;
    fn config_init(&self) -> bool;
    fn connection_pending(&self) -> bool;
    fn connection_up(&self) -> bool;
    fn conversation_builder(&self) -> &ConversationBuilder;
    fn conversation_builder_mut(&mut self) -> &mut ConversationBuilder;
    fn conversations(&self) -> &Conversations;
    fn conversations_mut(&mut self) -> &mut Conversations;
    fn errors(&self) -> &Errors;
    fn errors_mut(&mut self) -> &mut Errors;
    fn message_search(&self) -> &MessageSearch;
    fn message_search_mut(&mut self) -> &mut MessageSearch;
    fn users(&self) -> &Users;
    fn users_mut(&mut self) -> &mut Users;
    fn users_search(&self) -> &UsersSearch;
    fn users_search_mut(&mut self) -> &mut UsersSearch;
    fn utils(&self) -> &Utils;
    fn utils_mut(&mut self) -> &mut Utils;
    fn login(&mut self) -> bool;
    fn register_new_user(
        &mut self,
        user_id: String,
    ) -> ();
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
}

#[no_mangle]
pub extern "C" fn herald_new(
    herald: *mut HeraldQObject,
    config: *mut ConfigQObject,
    config_color_changed: fn(*mut ConfigQObject),
    config_colorscheme_changed: fn(*mut ConfigQObject),
    config_config_id_changed: fn(*mut ConfigQObject),
    config_name_changed: fn(*mut ConfigQObject),
    config_nts_conversation_id_changed: fn(*mut ConfigQObject),
    config_profile_picture_changed: fn(*mut ConfigQObject),
    herald_config_init_changed: fn(*mut HeraldQObject),
    herald_connection_pending_changed: fn(*mut HeraldQObject),
    herald_connection_up_changed: fn(*mut HeraldQObject),
    conversation_builder: *mut ConversationBuilderQObject,
    conversation_builder_picture_changed: fn(*mut ConversationBuilderQObject),
    conversation_builder_new_data_ready: fn(*mut ConversationBuilderQObject),
    conversation_builder_layout_about_to_be_changed: fn(*mut ConversationBuilderQObject),
    conversation_builder_layout_changed: fn(*mut ConversationBuilderQObject),
    conversation_builder_data_changed: fn(*mut ConversationBuilderQObject, usize, usize),
    conversation_builder_begin_reset_model: fn(*mut ConversationBuilderQObject),
    conversation_builder_end_reset_model: fn(*mut ConversationBuilderQObject),
    conversation_builder_begin_insert_rows: fn(*mut ConversationBuilderQObject, usize, usize),
    conversation_builder_end_insert_rows: fn(*mut ConversationBuilderQObject),
    conversation_builder_begin_move_rows: fn(*mut ConversationBuilderQObject, usize, usize, usize),
    conversation_builder_end_move_rows: fn(*mut ConversationBuilderQObject),
    conversation_builder_begin_remove_rows: fn(*mut ConversationBuilderQObject, usize, usize),
    conversation_builder_end_remove_rows: fn(*mut ConversationBuilderQObject),
    conversations: *mut ConversationsQObject,
    conversations_filter_changed: fn(*mut ConversationsQObject),
    conversations_filter_regex_changed: fn(*mut ConversationsQObject),
    conversations_new_data_ready: fn(*mut ConversationsQObject),
    conversations_layout_about_to_be_changed: fn(*mut ConversationsQObject),
    conversations_layout_changed: fn(*mut ConversationsQObject),
    conversations_data_changed: fn(*mut ConversationsQObject, usize, usize),
    conversations_begin_reset_model: fn(*mut ConversationsQObject),
    conversations_end_reset_model: fn(*mut ConversationsQObject),
    conversations_begin_insert_rows: fn(*mut ConversationsQObject, usize, usize),
    conversations_end_insert_rows: fn(*mut ConversationsQObject),
    conversations_begin_move_rows: fn(*mut ConversationsQObject, usize, usize, usize),
    conversations_end_move_rows: fn(*mut ConversationsQObject),
    conversations_begin_remove_rows: fn(*mut ConversationsQObject, usize, usize),
    conversations_end_remove_rows: fn(*mut ConversationsQObject),
    errors: *mut ErrorsQObject,
    errors_try_poll_changed: fn(*mut ErrorsQObject),
    message_search: *mut MessageSearchQObject,
    message_search_regex_search_changed: fn(*mut MessageSearchQObject),
    message_search_search_pattern_changed: fn(*mut MessageSearchQObject),
    message_search_new_data_ready: fn(*mut MessageSearchQObject),
    message_search_layout_about_to_be_changed: fn(*mut MessageSearchQObject),
    message_search_layout_changed: fn(*mut MessageSearchQObject),
    message_search_data_changed: fn(*mut MessageSearchQObject, usize, usize),
    message_search_begin_reset_model: fn(*mut MessageSearchQObject),
    message_search_end_reset_model: fn(*mut MessageSearchQObject),
    message_search_begin_insert_rows: fn(*mut MessageSearchQObject, usize, usize),
    message_search_end_insert_rows: fn(*mut MessageSearchQObject),
    message_search_begin_move_rows: fn(*mut MessageSearchQObject, usize, usize, usize),
    message_search_end_move_rows: fn(*mut MessageSearchQObject),
    message_search_begin_remove_rows: fn(*mut MessageSearchQObject, usize, usize),
    message_search_end_remove_rows: fn(*mut MessageSearchQObject),
    users: *mut UsersQObject,
    users_filter_changed: fn(*mut UsersQObject),
    users_filter_regex_changed: fn(*mut UsersQObject),
    users_new_data_ready: fn(*mut UsersQObject),
    users_layout_about_to_be_changed: fn(*mut UsersQObject),
    users_layout_changed: fn(*mut UsersQObject),
    users_data_changed: fn(*mut UsersQObject, usize, usize),
    users_begin_reset_model: fn(*mut UsersQObject),
    users_end_reset_model: fn(*mut UsersQObject),
    users_begin_insert_rows: fn(*mut UsersQObject, usize, usize),
    users_end_insert_rows: fn(*mut UsersQObject),
    users_begin_move_rows: fn(*mut UsersQObject, usize, usize, usize),
    users_end_move_rows: fn(*mut UsersQObject),
    users_begin_remove_rows: fn(*mut UsersQObject, usize, usize),
    users_end_remove_rows: fn(*mut UsersQObject),
    users_search: *mut UsersSearchQObject,
    users_search_filter_changed: fn(*mut UsersSearchQObject),
    users_search_new_data_ready: fn(*mut UsersSearchQObject),
    users_search_layout_about_to_be_changed: fn(*mut UsersSearchQObject),
    users_search_layout_changed: fn(*mut UsersSearchQObject),
    users_search_data_changed: fn(*mut UsersSearchQObject, usize, usize),
    users_search_begin_reset_model: fn(*mut UsersSearchQObject),
    users_search_end_reset_model: fn(*mut UsersSearchQObject),
    users_search_begin_insert_rows: fn(*mut UsersSearchQObject, usize, usize),
    users_search_end_insert_rows: fn(*mut UsersSearchQObject),
    users_search_begin_move_rows: fn(*mut UsersSearchQObject, usize, usize, usize),
    users_search_end_move_rows: fn(*mut UsersSearchQObject),
    users_search_begin_remove_rows: fn(*mut UsersSearchQObject, usize, usize),
    users_search_end_remove_rows: fn(*mut UsersSearchQObject),
    utils: *mut UtilsQObject,
    herald_new_data_ready: fn(*mut HeraldQObject),
    herald_layout_about_to_be_changed: fn(*mut HeraldQObject),
    herald_layout_changed: fn(*mut HeraldQObject),
    herald_data_changed: fn(*mut HeraldQObject, usize, usize),
    herald_begin_reset_model: fn(*mut HeraldQObject),
    herald_end_reset_model: fn(*mut HeraldQObject),
    herald_begin_insert_rows: fn(*mut HeraldQObject, usize, usize),
    herald_end_insert_rows: fn(*mut HeraldQObject),
    herald_begin_move_rows: fn(*mut HeraldQObject, usize, usize, usize),
    herald_end_move_rows: fn(*mut HeraldQObject),
    herald_begin_remove_rows: fn(*mut HeraldQObject, usize, usize),
    herald_end_remove_rows: fn(*mut HeraldQObject),
) -> *mut Herald {
    let config_emit = ConfigEmitter {
        qobject: Arc::new(AtomicPtr::new(config)),
        color_changed: config_color_changed,
        colorscheme_changed: config_colorscheme_changed,
        config_id_changed: config_config_id_changed,
        name_changed: config_name_changed,
        nts_conversation_id_changed: config_nts_conversation_id_changed,
        profile_picture_changed: config_profile_picture_changed,
    };
    let d_config = Config::new(config_emit);
    let conversation_builder_emit = ConversationBuilderEmitter {
        qobject: Arc::new(AtomicPtr::new(conversation_builder)),
        picture_changed: conversation_builder_picture_changed,
        new_data_ready: conversation_builder_new_data_ready,
    };
    let model = ConversationBuilderList {
        qobject: conversation_builder,
        layout_about_to_be_changed: conversation_builder_layout_about_to_be_changed,
        layout_changed: conversation_builder_layout_changed,
        data_changed: conversation_builder_data_changed,
        begin_reset_model: conversation_builder_begin_reset_model,
        end_reset_model: conversation_builder_end_reset_model,
        begin_insert_rows: conversation_builder_begin_insert_rows,
        end_insert_rows: conversation_builder_end_insert_rows,
        begin_move_rows: conversation_builder_begin_move_rows,
        end_move_rows: conversation_builder_end_move_rows,
        begin_remove_rows: conversation_builder_begin_remove_rows,
        end_remove_rows: conversation_builder_end_remove_rows,
    };
    let d_conversation_builder = ConversationBuilder::new(conversation_builder_emit, model);
    let conversations_emit = ConversationsEmitter {
        qobject: Arc::new(AtomicPtr::new(conversations)),
        filter_changed: conversations_filter_changed,
        filter_regex_changed: conversations_filter_regex_changed,
        new_data_ready: conversations_new_data_ready,
    };
    let model = ConversationsList {
        qobject: conversations,
        layout_about_to_be_changed: conversations_layout_about_to_be_changed,
        layout_changed: conversations_layout_changed,
        data_changed: conversations_data_changed,
        begin_reset_model: conversations_begin_reset_model,
        end_reset_model: conversations_end_reset_model,
        begin_insert_rows: conversations_begin_insert_rows,
        end_insert_rows: conversations_end_insert_rows,
        begin_move_rows: conversations_begin_move_rows,
        end_move_rows: conversations_end_move_rows,
        begin_remove_rows: conversations_begin_remove_rows,
        end_remove_rows: conversations_end_remove_rows,
    };
    let d_conversations = Conversations::new(conversations_emit, model);
    let errors_emit = ErrorsEmitter {
        qobject: Arc::new(AtomicPtr::new(errors)),
        try_poll_changed: errors_try_poll_changed,
    };
    let d_errors = Errors::new(errors_emit);
    let message_search_emit = MessageSearchEmitter {
        qobject: Arc::new(AtomicPtr::new(message_search)),
        regex_search_changed: message_search_regex_search_changed,
        search_pattern_changed: message_search_search_pattern_changed,
        new_data_ready: message_search_new_data_ready,
    };
    let model = MessageSearchList {
        qobject: message_search,
        layout_about_to_be_changed: message_search_layout_about_to_be_changed,
        layout_changed: message_search_layout_changed,
        data_changed: message_search_data_changed,
        begin_reset_model: message_search_begin_reset_model,
        end_reset_model: message_search_end_reset_model,
        begin_insert_rows: message_search_begin_insert_rows,
        end_insert_rows: message_search_end_insert_rows,
        begin_move_rows: message_search_begin_move_rows,
        end_move_rows: message_search_end_move_rows,
        begin_remove_rows: message_search_begin_remove_rows,
        end_remove_rows: message_search_end_remove_rows,
    };
    let d_message_search = MessageSearch::new(message_search_emit, model);
    let users_emit = UsersEmitter {
        qobject: Arc::new(AtomicPtr::new(users)),
        filter_changed: users_filter_changed,
        filter_regex_changed: users_filter_regex_changed,
        new_data_ready: users_new_data_ready,
    };
    let model = UsersList {
        qobject: users,
        layout_about_to_be_changed: users_layout_about_to_be_changed,
        layout_changed: users_layout_changed,
        data_changed: users_data_changed,
        begin_reset_model: users_begin_reset_model,
        end_reset_model: users_end_reset_model,
        begin_insert_rows: users_begin_insert_rows,
        end_insert_rows: users_end_insert_rows,
        begin_move_rows: users_begin_move_rows,
        end_move_rows: users_end_move_rows,
        begin_remove_rows: users_begin_remove_rows,
        end_remove_rows: users_end_remove_rows,
    };
    let d_users = Users::new(users_emit, model);
    let users_search_emit = UsersSearchEmitter {
        qobject: Arc::new(AtomicPtr::new(users_search)),
        filter_changed: users_search_filter_changed,
        new_data_ready: users_search_new_data_ready,
    };
    let model = UsersSearchList {
        qobject: users_search,
        layout_about_to_be_changed: users_search_layout_about_to_be_changed,
        layout_changed: users_search_layout_changed,
        data_changed: users_search_data_changed,
        begin_reset_model: users_search_begin_reset_model,
        end_reset_model: users_search_end_reset_model,
        begin_insert_rows: users_search_begin_insert_rows,
        end_insert_rows: users_search_end_insert_rows,
        begin_move_rows: users_search_begin_move_rows,
        end_move_rows: users_search_end_move_rows,
        begin_remove_rows: users_search_begin_remove_rows,
        end_remove_rows: users_search_end_remove_rows,
    };
    let d_users_search = UsersSearch::new(users_search_emit, model);
    let utils_emit = UtilsEmitter {
        qobject: Arc::new(AtomicPtr::new(utils)),
    };
    let d_utils = Utils::new(utils_emit);
    let herald_emit = HeraldEmitter {
        qobject: Arc::new(AtomicPtr::new(herald)),
        config_init_changed: herald_config_init_changed,
        connection_pending_changed: herald_connection_pending_changed,
        connection_up_changed: herald_connection_up_changed,
        new_data_ready: herald_new_data_ready,
    };
    let model = HeraldList {
        qobject: herald,
        layout_about_to_be_changed: herald_layout_about_to_be_changed,
        layout_changed: herald_layout_changed,
        data_changed: herald_data_changed,
        begin_reset_model: herald_begin_reset_model,
        end_reset_model: herald_end_reset_model,
        begin_insert_rows: herald_begin_insert_rows,
        end_insert_rows: herald_end_insert_rows,
        begin_move_rows: herald_begin_move_rows,
        end_move_rows: herald_end_move_rows,
        begin_remove_rows: herald_begin_remove_rows,
        end_remove_rows: herald_end_remove_rows,
    };
    let d_herald = Herald::new(
        herald_emit,
        model,
        d_config,
        d_conversation_builder,
        d_conversations,
        d_errors,
        d_message_search,
        d_users,
        d_users_search,
        d_utils,
    );
    Box::into_raw(Box::new(d_herald))
}

#[no_mangle]
pub unsafe extern "C" fn herald_free(ptr: *mut Herald) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn herald_config_get(ptr: *mut Herald) -> *mut Config {
    (&mut *ptr).config_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_config_init_get(ptr: *const Herald) -> bool {
    (&*ptr).config_init()
}

#[no_mangle]
pub unsafe extern "C" fn herald_connection_pending_get(ptr: *const Herald) -> bool {
    (&*ptr).connection_pending()
}

#[no_mangle]
pub unsafe extern "C" fn herald_connection_up_get(ptr: *const Herald) -> bool {
    (&*ptr).connection_up()
}

#[no_mangle]
pub unsafe extern "C" fn herald_conversation_builder_get(
    ptr: *mut Herald
) -> *mut ConversationBuilder {
    (&mut *ptr).conversation_builder_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_conversations_get(ptr: *mut Herald) -> *mut Conversations {
    (&mut *ptr).conversations_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_errors_get(ptr: *mut Herald) -> *mut Errors {
    (&mut *ptr).errors_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_message_search_get(ptr: *mut Herald) -> *mut MessageSearch {
    (&mut *ptr).message_search_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_users_get(ptr: *mut Herald) -> *mut Users {
    (&mut *ptr).users_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_users_search_get(ptr: *mut Herald) -> *mut UsersSearch {
    (&mut *ptr).users_search_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_utils_get(ptr: *mut Herald) -> *mut Utils {
    (&mut *ptr).utils_mut()
}

#[no_mangle]
pub unsafe extern "C" fn herald_login(ptr: *mut Herald) -> bool {
    let o = &mut *ptr;
    o.login()
}

#[no_mangle]
pub unsafe extern "C" fn herald_register_new_user(
    ptr: *mut Herald,
    user_id_str: *const c_ushort,
    user_id_len: c_int,
) {
    let mut user_id = String::new();
    set_string_from_utf16(&mut user_id, user_id_str, user_id_len);
    let o = &mut *ptr;
    o.register_new_user(user_id)
}

#[no_mangle]
pub unsafe extern "C" fn herald_row_count(ptr: *const Herald) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn herald_insert_rows(
    ptr: *mut Herald,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn herald_remove_rows(
    ptr: *mut Herald,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn herald_can_fetch_more(ptr: *const Herald) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn herald_fetch_more(ptr: *mut Herald) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn herald_sort(
    ptr: *mut Herald,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

pub struct MembersQObject {}

pub struct MembersEmitter {
    qobject: Arc<AtomicPtr<MembersQObject>>,
    conversation_id_changed: fn(*mut MembersQObject),
    filter_changed: fn(*mut MembersQObject),
    filter_regex_changed: fn(*mut MembersQObject),
    new_data_ready: fn(*mut MembersQObject),
}

impl MembersEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> MembersEmitter {
        MembersEmitter {
            qobject: self.qobject.clone(),
            conversation_id_changed: self.conversation_id_changed,
            filter_changed: self.filter_changed,
            filter_regex_changed: self.filter_regex_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const MembersQObject = null();
        self.qobject
            .store(n as *mut MembersQObject, Ordering::SeqCst);
    }
    pub fn conversation_id_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.conversation_id_changed)(ptr);
        }
    }
    pub fn filter_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.filter_changed)(ptr);
        }
    }
    pub fn filter_regex_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.filter_regex_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct MembersList {
    qobject: *mut MembersQObject,
    layout_about_to_be_changed: fn(*mut MembersQObject),
    layout_changed: fn(*mut MembersQObject),
    data_changed: fn(*mut MembersQObject, usize, usize),
    begin_reset_model: fn(*mut MembersQObject),
    end_reset_model: fn(*mut MembersQObject),
    begin_insert_rows: fn(*mut MembersQObject, usize, usize),
    end_insert_rows: fn(*mut MembersQObject),
    begin_move_rows: fn(*mut MembersQObject, usize, usize, usize),
    end_move_rows: fn(*mut MembersQObject),
    begin_remove_rows: fn(*mut MembersQObject, usize, usize),
    end_remove_rows: fn(*mut MembersQObject),
}

impl MembersList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait MembersTrait {
    fn new(
        emit: MembersEmitter,
        model: MembersList,
    ) -> Self;
    fn emit(&mut self) -> &mut MembersEmitter;
    fn conversation_id(&self) -> Option<&[u8]>;
    fn set_conversation_id(
        &mut self,
        value: Option<&[u8]>,
    );
    fn filter(&self) -> &str;
    fn set_filter(
        &mut self,
        value: String,
    );
    fn filter_regex(&self) -> bool;
    fn set_filter_regex(
        &mut self,
        value: bool,
    );
    fn add_to_conversation(
        &mut self,
        id: String,
    ) -> bool;
    fn remove_from_conversation_by_index(
        &mut self,
        row_index: u64,
    ) -> bool;
    fn toggle_filter_regex(&mut self) -> bool;
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn color(
        &self,
        index: usize,
    ) -> u32;
    fn matched(
        &self,
        index: usize,
    ) -> bool;
    fn name(
        &self,
        index: usize,
    ) -> String;
    fn pairwise_conversation_id(
        &self,
        index: usize,
    ) -> Vec<u8>;
    fn profile_picture(
        &self,
        index: usize,
    ) -> Option<String>;
    fn status(
        &self,
        index: usize,
    ) -> u8;
    fn user_id(
        &self,
        index: usize,
    ) -> &str;
}

#[no_mangle]
pub extern "C" fn members_new(
    members: *mut MembersQObject,
    members_conversation_id_changed: fn(*mut MembersQObject),
    members_filter_changed: fn(*mut MembersQObject),
    members_filter_regex_changed: fn(*mut MembersQObject),
    members_new_data_ready: fn(*mut MembersQObject),
    members_layout_about_to_be_changed: fn(*mut MembersQObject),
    members_layout_changed: fn(*mut MembersQObject),
    members_data_changed: fn(*mut MembersQObject, usize, usize),
    members_begin_reset_model: fn(*mut MembersQObject),
    members_end_reset_model: fn(*mut MembersQObject),
    members_begin_insert_rows: fn(*mut MembersQObject, usize, usize),
    members_end_insert_rows: fn(*mut MembersQObject),
    members_begin_move_rows: fn(*mut MembersQObject, usize, usize, usize),
    members_end_move_rows: fn(*mut MembersQObject),
    members_begin_remove_rows: fn(*mut MembersQObject, usize, usize),
    members_end_remove_rows: fn(*mut MembersQObject),
) -> *mut Members {
    let members_emit = MembersEmitter {
        qobject: Arc::new(AtomicPtr::new(members)),
        conversation_id_changed: members_conversation_id_changed,
        filter_changed: members_filter_changed,
        filter_regex_changed: members_filter_regex_changed,
        new_data_ready: members_new_data_ready,
    };
    let model = MembersList {
        qobject: members,
        layout_about_to_be_changed: members_layout_about_to_be_changed,
        layout_changed: members_layout_changed,
        data_changed: members_data_changed,
        begin_reset_model: members_begin_reset_model,
        end_reset_model: members_end_reset_model,
        begin_insert_rows: members_begin_insert_rows,
        end_insert_rows: members_end_insert_rows,
        begin_move_rows: members_begin_move_rows,
        end_move_rows: members_end_move_rows,
        begin_remove_rows: members_begin_remove_rows,
        end_remove_rows: members_end_remove_rows,
    };
    let d_members = Members::new(members_emit, model);
    Box::into_raw(Box::new(d_members))
}

#[no_mangle]
pub unsafe extern "C" fn members_free(ptr: *mut Members) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn members_conversation_id_get(
    ptr: *const Members,
    p: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.conversation_id();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn members_conversation_id_set(
    ptr: *mut Members,
    v: *const c_char,
    len: c_int,
) {
    let o = &mut *ptr;
    let v = qba_slice!(v, len);
    o.set_conversation_id(Some(v.into()));
}

#[no_mangle]
pub unsafe extern "C" fn members_conversation_id_set_none(ptr: *mut Members) {
    let o = &mut *ptr;
    o.set_conversation_id(None);
}

#[no_mangle]
pub unsafe extern "C" fn members_filter_get(
    ptr: *const Members,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.filter();
    let s: *const c_char = v.as_ptr() as (*const c_char);
    set(p, s, to_c_int(v.len()));
}

#[no_mangle]
pub unsafe extern "C" fn members_filter_set(
    ptr: *mut Members,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_filter(s);
}

#[no_mangle]
pub unsafe extern "C" fn members_filter_regex_get(ptr: *const Members) -> bool {
    (&*ptr).filter_regex()
}

#[no_mangle]
pub unsafe extern "C" fn members_filter_regex_set(
    ptr: *mut Members,
    v: bool,
) {
    (&mut *ptr).set_filter_regex(v);
}

#[no_mangle]
pub unsafe extern "C" fn members_add_to_conversation(
    ptr: *mut Members,
    id_str: *const c_ushort,
    id_len: c_int,
) -> bool {
    let mut id = String::new();
    set_string_from_utf16(&mut id, id_str, id_len);
    let o = &mut *ptr;
    o.add_to_conversation(id)
}

#[no_mangle]
pub unsafe extern "C" fn members_remove_from_conversation_by_index(
    ptr: *mut Members,
    row_index: u64,
) -> bool {
    let o = &mut *ptr;
    o.remove_from_conversation_by_index(row_index)
}

#[no_mangle]
pub unsafe extern "C" fn members_toggle_filter_regex(ptr: *mut Members) -> bool {
    let o = &mut *ptr;
    o.toggle_filter_regex()
}

#[no_mangle]
pub unsafe extern "C" fn members_row_count(ptr: *const Members) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn members_insert_rows(
    ptr: *mut Members,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn members_remove_rows(
    ptr: *mut Members,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn members_can_fetch_more(ptr: *const Members) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn members_fetch_more(ptr: *mut Members) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn members_sort(
    ptr: *mut Members,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn members_data_color(
    ptr: *const Members,
    row: c_int,
) -> u32 {
    let o = &*ptr;
    o.color(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn members_data_matched(
    ptr: *const Members,
    row: c_int,
) -> bool {
    let o = &*ptr;
    o.matched(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn members_data_name(
    ptr: *const Members,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.name(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

#[no_mangle]
pub unsafe extern "C" fn members_data_pairwise_conversation_id(
    ptr: *const Members,
    row: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.pairwise_conversation_id(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

#[no_mangle]
pub unsafe extern "C" fn members_data_profile_picture(
    ptr: *const Members,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.profile_picture(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn members_data_status(
    ptr: *const Members,
    row: c_int,
) -> u8 {
    let o = &*ptr;
    o.status(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn members_data_user_id(
    ptr: *const Members,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.user_id(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

pub struct MessageBuilderQObject {}

pub struct MessageBuilderEmitter {
    qobject: Arc<AtomicPtr<MessageBuilderQObject>>,
    body_changed: fn(*mut MessageBuilderQObject),
    is_media_message_changed: fn(*mut MessageBuilderQObject),
    is_reply_changed: fn(*mut MessageBuilderQObject),
    op_author_changed: fn(*mut MessageBuilderQObject),
    op_body_changed: fn(*mut MessageBuilderQObject),
    op_has_attachments_changed: fn(*mut MessageBuilderQObject),
    op_id_changed: fn(*mut MessageBuilderQObject),
    op_time_changed: fn(*mut MessageBuilderQObject),
    parse_markdown_changed: fn(*mut MessageBuilderQObject),
    new_data_ready: fn(*mut MessageBuilderQObject),
}

impl MessageBuilderEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> MessageBuilderEmitter {
        MessageBuilderEmitter {
            qobject: self.qobject.clone(),
            body_changed: self.body_changed,
            is_media_message_changed: self.is_media_message_changed,
            is_reply_changed: self.is_reply_changed,
            op_author_changed: self.op_author_changed,
            op_body_changed: self.op_body_changed,
            op_has_attachments_changed: self.op_has_attachments_changed,
            op_id_changed: self.op_id_changed,
            op_time_changed: self.op_time_changed,
            parse_markdown_changed: self.parse_markdown_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const MessageBuilderQObject = null();
        self.qobject
            .store(n as *mut MessageBuilderQObject, Ordering::SeqCst);
    }
    pub fn body_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.body_changed)(ptr);
        }
    }
    pub fn is_media_message_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.is_media_message_changed)(ptr);
        }
    }
    pub fn is_reply_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.is_reply_changed)(ptr);
        }
    }
    pub fn op_author_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.op_author_changed)(ptr);
        }
    }
    pub fn op_body_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.op_body_changed)(ptr);
        }
    }
    pub fn op_has_attachments_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.op_has_attachments_changed)(ptr);
        }
    }
    pub fn op_id_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.op_id_changed)(ptr);
        }
    }
    pub fn op_time_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.op_time_changed)(ptr);
        }
    }
    pub fn parse_markdown_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.parse_markdown_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct MessageBuilderList {
    qobject: *mut MessageBuilderQObject,
    layout_about_to_be_changed: fn(*mut MessageBuilderQObject),
    layout_changed: fn(*mut MessageBuilderQObject),
    data_changed: fn(*mut MessageBuilderQObject, usize, usize),
    begin_reset_model: fn(*mut MessageBuilderQObject),
    end_reset_model: fn(*mut MessageBuilderQObject),
    begin_insert_rows: fn(*mut MessageBuilderQObject, usize, usize),
    end_insert_rows: fn(*mut MessageBuilderQObject),
    begin_move_rows: fn(*mut MessageBuilderQObject, usize, usize, usize),
    end_move_rows: fn(*mut MessageBuilderQObject),
    begin_remove_rows: fn(*mut MessageBuilderQObject, usize, usize),
    end_remove_rows: fn(*mut MessageBuilderQObject),
}

impl MessageBuilderList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait MessageBuilderTrait {
    fn new(
        emit: MessageBuilderEmitter,
        model: MessageBuilderList,
    ) -> Self;
    fn emit(&mut self) -> &mut MessageBuilderEmitter;
    fn body(&self) -> Option<&str>;
    fn set_body(
        &mut self,
        value: Option<String>,
    );
    fn is_media_message(&self) -> bool;
    fn is_reply(&self) -> bool;
    fn op_author(&self) -> Option<&str>;
    fn op_body(&self) -> Option<&str>;
    fn op_has_attachments(&self) -> Option<bool>;
    fn op_id(&self) -> Option<&[u8]>;
    fn op_time(&self) -> Option<i64>;
    fn parse_markdown(&self) -> bool;
    fn set_parse_markdown(
        &mut self,
        value: bool,
    );
    fn add_attachment(
        &mut self,
        path: String,
    ) -> bool;
    fn clear_reply(&mut self) -> ();
    fn finalize(&mut self) -> ();
    fn remove_attachment(
        &mut self,
        path: String,
    ) -> bool;
    fn remove_attachment_by_index(
        &mut self,
        row_index: u64,
    ) -> bool;
    fn remove_last(&mut self) -> ();
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn attachment_path(
        &self,
        index: usize,
    ) -> &str;
}

#[no_mangle]
pub extern "C" fn message_builder_new(
    message_builder: *mut MessageBuilderQObject,
    message_builder_body_changed: fn(*mut MessageBuilderQObject),
    message_builder_is_media_message_changed: fn(*mut MessageBuilderQObject),
    message_builder_is_reply_changed: fn(*mut MessageBuilderQObject),
    message_builder_op_author_changed: fn(*mut MessageBuilderQObject),
    message_builder_op_body_changed: fn(*mut MessageBuilderQObject),
    message_builder_op_has_attachments_changed: fn(*mut MessageBuilderQObject),
    message_builder_op_id_changed: fn(*mut MessageBuilderQObject),
    message_builder_op_time_changed: fn(*mut MessageBuilderQObject),
    message_builder_parse_markdown_changed: fn(*mut MessageBuilderQObject),
    message_builder_new_data_ready: fn(*mut MessageBuilderQObject),
    message_builder_layout_about_to_be_changed: fn(*mut MessageBuilderQObject),
    message_builder_layout_changed: fn(*mut MessageBuilderQObject),
    message_builder_data_changed: fn(*mut MessageBuilderQObject, usize, usize),
    message_builder_begin_reset_model: fn(*mut MessageBuilderQObject),
    message_builder_end_reset_model: fn(*mut MessageBuilderQObject),
    message_builder_begin_insert_rows: fn(*mut MessageBuilderQObject, usize, usize),
    message_builder_end_insert_rows: fn(*mut MessageBuilderQObject),
    message_builder_begin_move_rows: fn(*mut MessageBuilderQObject, usize, usize, usize),
    message_builder_end_move_rows: fn(*mut MessageBuilderQObject),
    message_builder_begin_remove_rows: fn(*mut MessageBuilderQObject, usize, usize),
    message_builder_end_remove_rows: fn(*mut MessageBuilderQObject),
) -> *mut MessageBuilder {
    let message_builder_emit = MessageBuilderEmitter {
        qobject: Arc::new(AtomicPtr::new(message_builder)),
        body_changed: message_builder_body_changed,
        is_media_message_changed: message_builder_is_media_message_changed,
        is_reply_changed: message_builder_is_reply_changed,
        op_author_changed: message_builder_op_author_changed,
        op_body_changed: message_builder_op_body_changed,
        op_has_attachments_changed: message_builder_op_has_attachments_changed,
        op_id_changed: message_builder_op_id_changed,
        op_time_changed: message_builder_op_time_changed,
        parse_markdown_changed: message_builder_parse_markdown_changed,
        new_data_ready: message_builder_new_data_ready,
    };
    let model = MessageBuilderList {
        qobject: message_builder,
        layout_about_to_be_changed: message_builder_layout_about_to_be_changed,
        layout_changed: message_builder_layout_changed,
        data_changed: message_builder_data_changed,
        begin_reset_model: message_builder_begin_reset_model,
        end_reset_model: message_builder_end_reset_model,
        begin_insert_rows: message_builder_begin_insert_rows,
        end_insert_rows: message_builder_end_insert_rows,
        begin_move_rows: message_builder_begin_move_rows,
        end_move_rows: message_builder_end_move_rows,
        begin_remove_rows: message_builder_begin_remove_rows,
        end_remove_rows: message_builder_end_remove_rows,
    };
    let d_message_builder = MessageBuilder::new(message_builder_emit, model);
    Box::into_raw(Box::new(d_message_builder))
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_free(ptr: *mut MessageBuilder) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_body_get(
    ptr: *const MessageBuilder,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.body();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_body_set(
    ptr: *mut MessageBuilder,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_body(Some(s));
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_body_set_none(ptr: *mut MessageBuilder) {
    let o = &mut *ptr;
    o.set_body(None);
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_is_media_message_get(ptr: *const MessageBuilder) -> bool {
    (&*ptr).is_media_message()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_is_reply_get(ptr: *const MessageBuilder) -> bool {
    (&*ptr).is_reply()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_op_author_get(
    ptr: *const MessageBuilder,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.op_author();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_op_body_get(
    ptr: *const MessageBuilder,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.op_body();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_op_has_attachments_get(
    ptr: *const MessageBuilder
) -> COption<bool> {
    match (&*ptr).op_has_attachments() {
        Some(value) => COption {
            data: value,
            some: true,
        },
        None => COption {
            data: bool::default(),
            some: false,
        },
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_op_id_get(
    ptr: *const MessageBuilder,
    p: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.op_id();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_op_time_get(ptr: *const MessageBuilder) -> COption<i64> {
    match (&*ptr).op_time() {
        Some(value) => COption {
            data: value,
            some: true,
        },
        None => COption {
            data: i64::default(),
            some: false,
        },
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_parse_markdown_get(ptr: *const MessageBuilder) -> bool {
    (&*ptr).parse_markdown()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_parse_markdown_set(
    ptr: *mut MessageBuilder,
    v: bool,
) {
    (&mut *ptr).set_parse_markdown(v);
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_add_attachment(
    ptr: *mut MessageBuilder,
    path_str: *const c_ushort,
    path_len: c_int,
) -> bool {
    let mut path = String::new();
    set_string_from_utf16(&mut path, path_str, path_len);
    let o = &mut *ptr;
    o.add_attachment(path)
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_clear_reply(ptr: *mut MessageBuilder) {
    let o = &mut *ptr;
    o.clear_reply()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_finalize(ptr: *mut MessageBuilder) {
    let o = &mut *ptr;
    o.finalize()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_remove_attachment(
    ptr: *mut MessageBuilder,
    path_str: *const c_ushort,
    path_len: c_int,
) -> bool {
    let mut path = String::new();
    set_string_from_utf16(&mut path, path_str, path_len);
    let o = &mut *ptr;
    o.remove_attachment(path)
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_remove_attachment_by_index(
    ptr: *mut MessageBuilder,
    row_index: u64,
) -> bool {
    let o = &mut *ptr;
    o.remove_attachment_by_index(row_index)
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_remove_last(ptr: *mut MessageBuilder) {
    let o = &mut *ptr;
    o.remove_last()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_row_count(ptr: *const MessageBuilder) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_insert_rows(
    ptr: *mut MessageBuilder,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_remove_rows(
    ptr: *mut MessageBuilder,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_can_fetch_more(ptr: *const MessageBuilder) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_fetch_more(ptr: *mut MessageBuilder) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_sort(
    ptr: *mut MessageBuilder,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn message_builder_data_attachment_path(
    ptr: *const MessageBuilder,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.attachment_path(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

pub struct MessageSearchQObject {}

pub struct MessageSearchEmitter {
    qobject: Arc<AtomicPtr<MessageSearchQObject>>,
    regex_search_changed: fn(*mut MessageSearchQObject),
    search_pattern_changed: fn(*mut MessageSearchQObject),
    new_data_ready: fn(*mut MessageSearchQObject),
}

impl MessageSearchEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> MessageSearchEmitter {
        MessageSearchEmitter {
            qobject: self.qobject.clone(),
            regex_search_changed: self.regex_search_changed,
            search_pattern_changed: self.search_pattern_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const MessageSearchQObject = null();
        self.qobject
            .store(n as *mut MessageSearchQObject, Ordering::SeqCst);
    }
    pub fn regex_search_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.regex_search_changed)(ptr);
        }
    }
    pub fn search_pattern_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.search_pattern_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct MessageSearchList {
    qobject: *mut MessageSearchQObject,
    layout_about_to_be_changed: fn(*mut MessageSearchQObject),
    layout_changed: fn(*mut MessageSearchQObject),
    data_changed: fn(*mut MessageSearchQObject, usize, usize),
    begin_reset_model: fn(*mut MessageSearchQObject),
    end_reset_model: fn(*mut MessageSearchQObject),
    begin_insert_rows: fn(*mut MessageSearchQObject, usize, usize),
    end_insert_rows: fn(*mut MessageSearchQObject),
    begin_move_rows: fn(*mut MessageSearchQObject, usize, usize, usize),
    end_move_rows: fn(*mut MessageSearchQObject),
    begin_remove_rows: fn(*mut MessageSearchQObject, usize, usize),
    end_remove_rows: fn(*mut MessageSearchQObject),
}

impl MessageSearchList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait MessageSearchTrait {
    fn new(
        emit: MessageSearchEmitter,
        model: MessageSearchList,
    ) -> Self;
    fn emit(&mut self) -> &mut MessageSearchEmitter;
    fn regex_search(&self) -> Option<bool>;
    fn set_regex_search(
        &mut self,
        value: Option<bool>,
    );
    fn search_pattern(&self) -> Option<&str>;
    fn set_search_pattern(
        &mut self,
        value: Option<String>,
    );
    fn clear_search(&mut self) -> ();
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn author(
        &self,
        index: usize,
    ) -> Option<&str>;
    fn body(
        &self,
        index: usize,
    ) -> Option<&str>;
    fn conversation(
        &self,
        index: usize,
    ) -> Option<&[u8]>;
    fn conversation_color(
        &self,
        index: usize,
    ) -> Option<u32>;
    fn conversation_pairwise(
        &self,
        index: usize,
    ) -> Option<bool>;
    fn conversation_picture(
        &self,
        index: usize,
    ) -> Option<String>;
    fn conversation_title(
        &self,
        index: usize,
    ) -> Option<String>;
    fn has_attachments(
        &self,
        index: usize,
    ) -> Option<bool>;
    fn msg_id(
        &self,
        index: usize,
    ) -> Option<&[u8]>;
    fn time(
        &self,
        index: usize,
    ) -> Option<i64>;
}

#[no_mangle]
pub extern "C" fn message_search_new(
    message_search: *mut MessageSearchQObject,
    message_search_regex_search_changed: fn(*mut MessageSearchQObject),
    message_search_search_pattern_changed: fn(*mut MessageSearchQObject),
    message_search_new_data_ready: fn(*mut MessageSearchQObject),
    message_search_layout_about_to_be_changed: fn(*mut MessageSearchQObject),
    message_search_layout_changed: fn(*mut MessageSearchQObject),
    message_search_data_changed: fn(*mut MessageSearchQObject, usize, usize),
    message_search_begin_reset_model: fn(*mut MessageSearchQObject),
    message_search_end_reset_model: fn(*mut MessageSearchQObject),
    message_search_begin_insert_rows: fn(*mut MessageSearchQObject, usize, usize),
    message_search_end_insert_rows: fn(*mut MessageSearchQObject),
    message_search_begin_move_rows: fn(*mut MessageSearchQObject, usize, usize, usize),
    message_search_end_move_rows: fn(*mut MessageSearchQObject),
    message_search_begin_remove_rows: fn(*mut MessageSearchQObject, usize, usize),
    message_search_end_remove_rows: fn(*mut MessageSearchQObject),
) -> *mut MessageSearch {
    let message_search_emit = MessageSearchEmitter {
        qobject: Arc::new(AtomicPtr::new(message_search)),
        regex_search_changed: message_search_regex_search_changed,
        search_pattern_changed: message_search_search_pattern_changed,
        new_data_ready: message_search_new_data_ready,
    };
    let model = MessageSearchList {
        qobject: message_search,
        layout_about_to_be_changed: message_search_layout_about_to_be_changed,
        layout_changed: message_search_layout_changed,
        data_changed: message_search_data_changed,
        begin_reset_model: message_search_begin_reset_model,
        end_reset_model: message_search_end_reset_model,
        begin_insert_rows: message_search_begin_insert_rows,
        end_insert_rows: message_search_end_insert_rows,
        begin_move_rows: message_search_begin_move_rows,
        end_move_rows: message_search_end_move_rows,
        begin_remove_rows: message_search_begin_remove_rows,
        end_remove_rows: message_search_end_remove_rows,
    };
    let d_message_search = MessageSearch::new(message_search_emit, model);
    Box::into_raw(Box::new(d_message_search))
}

#[no_mangle]
pub unsafe extern "C" fn message_search_free(ptr: *mut MessageSearch) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn message_search_regex_search_get(
    ptr: *const MessageSearch
) -> COption<bool> {
    match (&*ptr).regex_search() {
        Some(value) => COption {
            data: value,
            some: true,
        },
        None => COption {
            data: bool::default(),
            some: false,
        },
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_regex_search_set(
    ptr: *mut MessageSearch,
    v: bool,
) {
    (&mut *ptr).set_regex_search(Some(v));
}

#[no_mangle]
pub unsafe extern "C" fn message_search_regex_search_set_none(ptr: *mut MessageSearch) {
    let o = &mut *ptr;
    o.set_regex_search(None);
}

#[no_mangle]
pub unsafe extern "C" fn message_search_search_pattern_get(
    ptr: *const MessageSearch,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.search_pattern();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_search_pattern_set(
    ptr: *mut MessageSearch,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_search_pattern(Some(s));
}

#[no_mangle]
pub unsafe extern "C" fn message_search_search_pattern_set_none(ptr: *mut MessageSearch) {
    let o = &mut *ptr;
    o.set_search_pattern(None);
}

#[no_mangle]
pub unsafe extern "C" fn message_search_clear_search(ptr: *mut MessageSearch) {
    let o = &mut *ptr;
    o.clear_search()
}

#[no_mangle]
pub unsafe extern "C" fn message_search_row_count(ptr: *const MessageSearch) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn message_search_insert_rows(
    ptr: *mut MessageSearch,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_remove_rows(
    ptr: *mut MessageSearch,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_can_fetch_more(ptr: *const MessageSearch) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn message_search_fetch_more(ptr: *mut MessageSearch) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn message_search_sort(
    ptr: *mut MessageSearch,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_author(
    ptr: *const MessageSearch,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.author(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_body(
    ptr: *const MessageSearch,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.body(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_conversation(
    ptr: *const MessageSearch,
    row: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.conversation(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_conversation_color(
    ptr: *const MessageSearch,
    row: c_int,
) -> COption<u32> {
    let o = &*ptr;
    o.conversation_color(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_conversation_pairwise(
    ptr: *const MessageSearch,
    row: c_int,
) -> COption<bool> {
    let o = &*ptr;
    o.conversation_pairwise(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_conversation_picture(
    ptr: *const MessageSearch,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.conversation_picture(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_conversation_title(
    ptr: *const MessageSearch,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.conversation_title(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_has_attachments(
    ptr: *const MessageSearch,
    row: c_int,
) -> COption<bool> {
    let o = &*ptr;
    o.has_attachments(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_msg_id(
    ptr: *const MessageSearch,
    row: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.msg_id(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn message_search_data_time(
    ptr: *const MessageSearch,
    row: c_int,
) -> COption<i64> {
    let o = &*ptr;
    o.time(to_usize(row).unwrap_or(0)).into()
}

pub struct MessagesQObject {}

pub struct MessagesEmitter {
    qobject: Arc<AtomicPtr<MessagesQObject>>,
    builder_op_msg_id_changed: fn(*mut MessagesQObject),
    conversation_id_changed: fn(*mut MessagesQObject),
    is_empty_changed: fn(*mut MessagesQObject),
    last_author_changed: fn(*mut MessagesQObject),
    last_body_changed: fn(*mut MessagesQObject),
    last_status_changed: fn(*mut MessagesQObject),
    last_time_changed: fn(*mut MessagesQObject),
    search_active_changed: fn(*mut MessagesQObject),
    search_index_changed: fn(*mut MessagesQObject),
    search_num_matches_changed: fn(*mut MessagesQObject),
    search_pattern_changed: fn(*mut MessagesQObject),
    search_regex_changed: fn(*mut MessagesQObject),
    new_data_ready: fn(*mut MessagesQObject),
}

impl MessagesEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> MessagesEmitter {
        MessagesEmitter {
            qobject: self.qobject.clone(),
            builder_op_msg_id_changed: self.builder_op_msg_id_changed,
            conversation_id_changed: self.conversation_id_changed,
            is_empty_changed: self.is_empty_changed,
            last_author_changed: self.last_author_changed,
            last_body_changed: self.last_body_changed,
            last_status_changed: self.last_status_changed,
            last_time_changed: self.last_time_changed,
            search_active_changed: self.search_active_changed,
            search_index_changed: self.search_index_changed,
            search_num_matches_changed: self.search_num_matches_changed,
            search_pattern_changed: self.search_pattern_changed,
            search_regex_changed: self.search_regex_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const MessagesQObject = null();
        self.qobject
            .store(n as *mut MessagesQObject, Ordering::SeqCst);
    }
    pub fn builder_op_msg_id_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.builder_op_msg_id_changed)(ptr);
        }
    }
    pub fn conversation_id_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.conversation_id_changed)(ptr);
        }
    }
    pub fn is_empty_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.is_empty_changed)(ptr);
        }
    }
    pub fn last_author_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.last_author_changed)(ptr);
        }
    }
    pub fn last_body_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.last_body_changed)(ptr);
        }
    }
    pub fn last_status_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.last_status_changed)(ptr);
        }
    }
    pub fn last_time_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.last_time_changed)(ptr);
        }
    }
    pub fn search_active_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.search_active_changed)(ptr);
        }
    }
    pub fn search_index_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.search_index_changed)(ptr);
        }
    }
    pub fn search_num_matches_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.search_num_matches_changed)(ptr);
        }
    }
    pub fn search_pattern_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.search_pattern_changed)(ptr);
        }
    }
    pub fn search_regex_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.search_regex_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct MessagesList {
    qobject: *mut MessagesQObject,
    layout_about_to_be_changed: fn(*mut MessagesQObject),
    layout_changed: fn(*mut MessagesQObject),
    data_changed: fn(*mut MessagesQObject, usize, usize),
    begin_reset_model: fn(*mut MessagesQObject),
    end_reset_model: fn(*mut MessagesQObject),
    begin_insert_rows: fn(*mut MessagesQObject, usize, usize),
    end_insert_rows: fn(*mut MessagesQObject),
    begin_move_rows: fn(*mut MessagesQObject, usize, usize, usize),
    end_move_rows: fn(*mut MessagesQObject),
    begin_remove_rows: fn(*mut MessagesQObject, usize, usize),
    end_remove_rows: fn(*mut MessagesQObject),
}

impl MessagesList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait MessagesTrait {
    fn new(
        emit: MessagesEmitter,
        model: MessagesList,
        builder: MessageBuilder,
    ) -> Self;
    fn emit(&mut self) -> &mut MessagesEmitter;
    fn builder(&self) -> &MessageBuilder;
    fn builder_mut(&mut self) -> &mut MessageBuilder;
    fn builder_op_msg_id(&self) -> Option<&[u8]>;
    fn set_builder_op_msg_id(
        &mut self,
        value: Option<&[u8]>,
    );
    fn conversation_id(&self) -> Option<&[u8]>;
    fn set_conversation_id(
        &mut self,
        value: Option<&[u8]>,
    );
    fn is_empty(&self) -> bool;
    fn last_author(&self) -> Option<&str>;
    fn last_body(&self) -> Option<&str>;
    fn last_status(&self) -> Option<u32>;
    fn last_time(&self) -> Option<i64>;
    fn search_active(&self) -> bool;
    fn set_search_active(
        &mut self,
        value: bool,
    );
    fn search_index(&self) -> u64;
    fn search_num_matches(&self) -> u64;
    fn search_pattern(&self) -> &str;
    fn set_search_pattern(
        &mut self,
        value: String,
    );
    fn search_regex(&self) -> bool;
    fn set_search_regex(
        &mut self,
        value: bool,
    );
    fn clear_conversation_history(&mut self) -> bool;
    fn clear_search(&mut self) -> ();
    fn delete_message(
        &mut self,
        row_index: u64,
    ) -> bool;
    fn index_by_id(
        &self,
        msg_id: &[u8],
    ) -> u64;
    fn next_search_match(&mut self) -> i64;
    fn prev_search_match(&mut self) -> i64;
    fn set_search_hint(
        &mut self,
        scrollbar_position: f32,
        scrollbar_height: f32,
    ) -> ();
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn author(
        &self,
        index: usize,
    ) -> Option<&str>;
    fn body(
        &self,
        index: usize,
    ) -> Option<&str>;
    fn data_saved(
        &self,
        index: usize,
    ) -> Option<bool>;
    fn expiration_time(
        &self,
        index: usize,
    ) -> Option<i64>;
    fn has_attachments(
        &self,
        index: usize,
    ) -> Option<bool>;
    fn insertion_time(
        &self,
        index: usize,
    ) -> Option<i64>;
    fn is_head(
        &self,
        index: usize,
    ) -> Option<bool>;
    fn is_tail(
        &self,
        index: usize,
    ) -> Option<bool>;
    fn match_status(
        &self,
        index: usize,
    ) -> Option<u8>;
    fn msg_id(
        &self,
        index: usize,
    ) -> Option<&[u8]>;
    fn op_author(
        &self,
        index: usize,
    ) -> Option<&str>;
    fn op_body(
        &self,
        index: usize,
    ) -> Option<&str>;
    fn op_expiration_time(
        &self,
        index: usize,
    ) -> Option<i64>;
    fn op_has_attachments(
        &self,
        index: usize,
    ) -> Option<bool>;
    fn op_insertion_time(
        &self,
        index: usize,
    ) -> Option<i64>;
    fn op_msg_id(
        &self,
        index: usize,
    ) -> Option<&[u8]>;
    fn receipt_status(
        &self,
        index: usize,
    ) -> Option<u32>;
    fn reply_type(
        &self,
        index: usize,
    ) -> Option<u8>;
    fn server_time(
        &self,
        index: usize,
    ) -> Option<i64>;
}

#[no_mangle]
pub extern "C" fn messages_new(
    messages: *mut MessagesQObject,
    builder: *mut MessageBuilderQObject,
    builder_body_changed: fn(*mut MessageBuilderQObject),
    builder_is_media_message_changed: fn(*mut MessageBuilderQObject),
    builder_is_reply_changed: fn(*mut MessageBuilderQObject),
    builder_op_author_changed: fn(*mut MessageBuilderQObject),
    builder_op_body_changed: fn(*mut MessageBuilderQObject),
    builder_op_has_attachments_changed: fn(*mut MessageBuilderQObject),
    builder_op_id_changed: fn(*mut MessageBuilderQObject),
    builder_op_time_changed: fn(*mut MessageBuilderQObject),
    builder_parse_markdown_changed: fn(*mut MessageBuilderQObject),
    builder_new_data_ready: fn(*mut MessageBuilderQObject),
    builder_layout_about_to_be_changed: fn(*mut MessageBuilderQObject),
    builder_layout_changed: fn(*mut MessageBuilderQObject),
    builder_data_changed: fn(*mut MessageBuilderQObject, usize, usize),
    builder_begin_reset_model: fn(*mut MessageBuilderQObject),
    builder_end_reset_model: fn(*mut MessageBuilderQObject),
    builder_begin_insert_rows: fn(*mut MessageBuilderQObject, usize, usize),
    builder_end_insert_rows: fn(*mut MessageBuilderQObject),
    builder_begin_move_rows: fn(*mut MessageBuilderQObject, usize, usize, usize),
    builder_end_move_rows: fn(*mut MessageBuilderQObject),
    builder_begin_remove_rows: fn(*mut MessageBuilderQObject, usize, usize),
    builder_end_remove_rows: fn(*mut MessageBuilderQObject),
    messages_builder_op_msg_id_changed: fn(*mut MessagesQObject),
    messages_conversation_id_changed: fn(*mut MessagesQObject),
    messages_is_empty_changed: fn(*mut MessagesQObject),
    messages_last_author_changed: fn(*mut MessagesQObject),
    messages_last_body_changed: fn(*mut MessagesQObject),
    messages_last_status_changed: fn(*mut MessagesQObject),
    messages_last_time_changed: fn(*mut MessagesQObject),
    messages_search_active_changed: fn(*mut MessagesQObject),
    messages_search_index_changed: fn(*mut MessagesQObject),
    messages_search_num_matches_changed: fn(*mut MessagesQObject),
    messages_search_pattern_changed: fn(*mut MessagesQObject),
    messages_search_regex_changed: fn(*mut MessagesQObject),
    messages_new_data_ready: fn(*mut MessagesQObject),
    messages_layout_about_to_be_changed: fn(*mut MessagesQObject),
    messages_layout_changed: fn(*mut MessagesQObject),
    messages_data_changed: fn(*mut MessagesQObject, usize, usize),
    messages_begin_reset_model: fn(*mut MessagesQObject),
    messages_end_reset_model: fn(*mut MessagesQObject),
    messages_begin_insert_rows: fn(*mut MessagesQObject, usize, usize),
    messages_end_insert_rows: fn(*mut MessagesQObject),
    messages_begin_move_rows: fn(*mut MessagesQObject, usize, usize, usize),
    messages_end_move_rows: fn(*mut MessagesQObject),
    messages_begin_remove_rows: fn(*mut MessagesQObject, usize, usize),
    messages_end_remove_rows: fn(*mut MessagesQObject),
) -> *mut Messages {
    let builder_emit = MessageBuilderEmitter {
        qobject: Arc::new(AtomicPtr::new(builder)),
        body_changed: builder_body_changed,
        is_media_message_changed: builder_is_media_message_changed,
        is_reply_changed: builder_is_reply_changed,
        op_author_changed: builder_op_author_changed,
        op_body_changed: builder_op_body_changed,
        op_has_attachments_changed: builder_op_has_attachments_changed,
        op_id_changed: builder_op_id_changed,
        op_time_changed: builder_op_time_changed,
        parse_markdown_changed: builder_parse_markdown_changed,
        new_data_ready: builder_new_data_ready,
    };
    let model = MessageBuilderList {
        qobject: builder,
        layout_about_to_be_changed: builder_layout_about_to_be_changed,
        layout_changed: builder_layout_changed,
        data_changed: builder_data_changed,
        begin_reset_model: builder_begin_reset_model,
        end_reset_model: builder_end_reset_model,
        begin_insert_rows: builder_begin_insert_rows,
        end_insert_rows: builder_end_insert_rows,
        begin_move_rows: builder_begin_move_rows,
        end_move_rows: builder_end_move_rows,
        begin_remove_rows: builder_begin_remove_rows,
        end_remove_rows: builder_end_remove_rows,
    };
    let d_builder = MessageBuilder::new(builder_emit, model);
    let messages_emit = MessagesEmitter {
        qobject: Arc::new(AtomicPtr::new(messages)),
        builder_op_msg_id_changed: messages_builder_op_msg_id_changed,
        conversation_id_changed: messages_conversation_id_changed,
        is_empty_changed: messages_is_empty_changed,
        last_author_changed: messages_last_author_changed,
        last_body_changed: messages_last_body_changed,
        last_status_changed: messages_last_status_changed,
        last_time_changed: messages_last_time_changed,
        search_active_changed: messages_search_active_changed,
        search_index_changed: messages_search_index_changed,
        search_num_matches_changed: messages_search_num_matches_changed,
        search_pattern_changed: messages_search_pattern_changed,
        search_regex_changed: messages_search_regex_changed,
        new_data_ready: messages_new_data_ready,
    };
    let model = MessagesList {
        qobject: messages,
        layout_about_to_be_changed: messages_layout_about_to_be_changed,
        layout_changed: messages_layout_changed,
        data_changed: messages_data_changed,
        begin_reset_model: messages_begin_reset_model,
        end_reset_model: messages_end_reset_model,
        begin_insert_rows: messages_begin_insert_rows,
        end_insert_rows: messages_end_insert_rows,
        begin_move_rows: messages_begin_move_rows,
        end_move_rows: messages_end_move_rows,
        begin_remove_rows: messages_begin_remove_rows,
        end_remove_rows: messages_end_remove_rows,
    };
    let d_messages = Messages::new(messages_emit, model, d_builder);
    Box::into_raw(Box::new(d_messages))
}

#[no_mangle]
pub unsafe extern "C" fn messages_free(ptr: *mut Messages) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn messages_builder_get(ptr: *mut Messages) -> *mut MessageBuilder {
    (&mut *ptr).builder_mut()
}

#[no_mangle]
pub unsafe extern "C" fn messages_builder_op_msg_id_get(
    ptr: *const Messages,
    p: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.builder_op_msg_id();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_builder_op_msg_id_set(
    ptr: *mut Messages,
    v: *const c_char,
    len: c_int,
) {
    let o = &mut *ptr;
    let v = qba_slice!(v, len);
    o.set_builder_op_msg_id(Some(v.into()));
}

#[no_mangle]
pub unsafe extern "C" fn messages_builder_op_msg_id_set_none(ptr: *mut Messages) {
    let o = &mut *ptr;
    o.set_builder_op_msg_id(None);
}

#[no_mangle]
pub unsafe extern "C" fn messages_conversation_id_get(
    ptr: *const Messages,
    p: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.conversation_id();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_conversation_id_set(
    ptr: *mut Messages,
    v: *const c_char,
    len: c_int,
) {
    let o = &mut *ptr;
    let v = qba_slice!(v, len);
    o.set_conversation_id(Some(v.into()));
}

#[no_mangle]
pub unsafe extern "C" fn messages_conversation_id_set_none(ptr: *mut Messages) {
    let o = &mut *ptr;
    o.set_conversation_id(None);
}

#[no_mangle]
pub unsafe extern "C" fn messages_is_empty_get(ptr: *const Messages) -> bool {
    (&*ptr).is_empty()
}

#[no_mangle]
pub unsafe extern "C" fn messages_last_author_get(
    ptr: *const Messages,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.last_author();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_last_body_get(
    ptr: *const Messages,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.last_body();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_last_status_get(ptr: *const Messages) -> COption<u32> {
    match (&*ptr).last_status() {
        Some(value) => COption {
            data: value,
            some: true,
        },
        None => COption {
            data: u32::default(),
            some: false,
        },
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_last_time_get(ptr: *const Messages) -> COption<i64> {
    match (&*ptr).last_time() {
        Some(value) => COption {
            data: value,
            some: true,
        },
        None => COption {
            data: i64::default(),
            some: false,
        },
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_active_get(ptr: *const Messages) -> bool {
    (&*ptr).search_active()
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_active_set(
    ptr: *mut Messages,
    v: bool,
) {
    (&mut *ptr).set_search_active(v);
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_index_get(ptr: *const Messages) -> u64 {
    (&*ptr).search_index()
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_num_matches_get(ptr: *const Messages) -> u64 {
    (&*ptr).search_num_matches()
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_pattern_get(
    ptr: *const Messages,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.search_pattern();
    let s: *const c_char = v.as_ptr() as (*const c_char);
    set(p, s, to_c_int(v.len()));
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_pattern_set(
    ptr: *mut Messages,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_search_pattern(s);
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_regex_get(ptr: *const Messages) -> bool {
    (&*ptr).search_regex()
}

#[no_mangle]
pub unsafe extern "C" fn messages_search_regex_set(
    ptr: *mut Messages,
    v: bool,
) {
    (&mut *ptr).set_search_regex(v);
}

#[no_mangle]
pub unsafe extern "C" fn messages_clear_conversation_history(ptr: *mut Messages) -> bool {
    let o = &mut *ptr;
    o.clear_conversation_history()
}

#[no_mangle]
pub unsafe extern "C" fn messages_clear_search(ptr: *mut Messages) {
    let o = &mut *ptr;
    o.clear_search()
}

#[no_mangle]
pub unsafe extern "C" fn messages_delete_message(
    ptr: *mut Messages,
    row_index: u64,
) -> bool {
    let o = &mut *ptr;
    o.delete_message(row_index)
}

#[no_mangle]
pub unsafe extern "C" fn messages_index_by_id(
    ptr: *const Messages,
    msg_id_str: *const c_char,
    msg_id_len: c_int,
) -> u64 {
    let msg_id = { qba_slice!(msg_id_str, msg_id_len) };
    let o = &*ptr;
    o.index_by_id(msg_id)
}

#[no_mangle]
pub unsafe extern "C" fn messages_next_search_match(ptr: *mut Messages) -> i64 {
    let o = &mut *ptr;
    o.next_search_match()
}

#[no_mangle]
pub unsafe extern "C" fn messages_prev_search_match(ptr: *mut Messages) -> i64 {
    let o = &mut *ptr;
    o.prev_search_match()
}

#[no_mangle]
pub unsafe extern "C" fn messages_set_search_hint(
    ptr: *mut Messages,
    scrollbar_position: f32,
    scrollbar_height: f32,
) {
    let o = &mut *ptr;
    o.set_search_hint(scrollbar_position, scrollbar_height)
}

#[no_mangle]
pub unsafe extern "C" fn messages_row_count(ptr: *const Messages) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn messages_insert_rows(
    ptr: *mut Messages,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_remove_rows(
    ptr: *mut Messages,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_can_fetch_more(ptr: *const Messages) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn messages_fetch_more(ptr: *mut Messages) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn messages_sort(
    ptr: *mut Messages,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_author(
    ptr: *const Messages,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.author(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_body(
    ptr: *const Messages,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.body(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_data_saved(
    ptr: *const Messages,
    row: c_int,
) -> COption<bool> {
    let o = &*ptr;
    o.data_saved(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_expiration_time(
    ptr: *const Messages,
    row: c_int,
) -> COption<i64> {
    let o = &*ptr;
    o.expiration_time(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_has_attachments(
    ptr: *const Messages,
    row: c_int,
) -> COption<bool> {
    let o = &*ptr;
    o.has_attachments(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_insertion_time(
    ptr: *const Messages,
    row: c_int,
) -> COption<i64> {
    let o = &*ptr;
    o.insertion_time(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_is_head(
    ptr: *const Messages,
    row: c_int,
) -> COption<bool> {
    let o = &*ptr;
    o.is_head(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_is_tail(
    ptr: *const Messages,
    row: c_int,
) -> COption<bool> {
    let o = &*ptr;
    o.is_tail(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_match_status(
    ptr: *const Messages,
    row: c_int,
) -> COption<u8> {
    let o = &*ptr;
    o.match_status(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_msg_id(
    ptr: *const Messages,
    row: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.msg_id(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_op_author(
    ptr: *const Messages,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.op_author(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_op_body(
    ptr: *const Messages,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.op_body(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_op_expiration_time(
    ptr: *const Messages,
    row: c_int,
) -> COption<i64> {
    let o = &*ptr;
    o.op_expiration_time(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_op_has_attachments(
    ptr: *const Messages,
    row: c_int,
) -> COption<bool> {
    let o = &*ptr;
    o.op_has_attachments(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_op_insertion_time(
    ptr: *const Messages,
    row: c_int,
) -> COption<i64> {
    let o = &*ptr;
    o.op_insertion_time(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_op_msg_id(
    ptr: *const Messages,
    row: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.op_msg_id(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_receipt_status(
    ptr: *const Messages,
    row: c_int,
) -> COption<u32> {
    let o = &*ptr;
    o.receipt_status(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_reply_type(
    ptr: *const Messages,
    row: c_int,
) -> COption<u8> {
    let o = &*ptr;
    o.reply_type(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn messages_data_server_time(
    ptr: *const Messages,
    row: c_int,
) -> COption<i64> {
    let o = &*ptr;
    o.server_time(to_usize(row).unwrap_or(0)).into()
}

pub struct UsersQObject {}

pub struct UsersEmitter {
    qobject: Arc<AtomicPtr<UsersQObject>>,
    filter_changed: fn(*mut UsersQObject),
    filter_regex_changed: fn(*mut UsersQObject),
    new_data_ready: fn(*mut UsersQObject),
}

impl UsersEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> UsersEmitter {
        UsersEmitter {
            qobject: self.qobject.clone(),
            filter_changed: self.filter_changed,
            filter_regex_changed: self.filter_regex_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const UsersQObject = null();
        self.qobject.store(n as *mut UsersQObject, Ordering::SeqCst);
    }
    pub fn filter_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.filter_changed)(ptr);
        }
    }
    pub fn filter_regex_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.filter_regex_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct UsersList {
    qobject: *mut UsersQObject,
    layout_about_to_be_changed: fn(*mut UsersQObject),
    layout_changed: fn(*mut UsersQObject),
    data_changed: fn(*mut UsersQObject, usize, usize),
    begin_reset_model: fn(*mut UsersQObject),
    end_reset_model: fn(*mut UsersQObject),
    begin_insert_rows: fn(*mut UsersQObject, usize, usize),
    end_insert_rows: fn(*mut UsersQObject),
    begin_move_rows: fn(*mut UsersQObject, usize, usize, usize),
    end_move_rows: fn(*mut UsersQObject),
    begin_remove_rows: fn(*mut UsersQObject, usize, usize),
    end_remove_rows: fn(*mut UsersQObject),
}

impl UsersList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait UsersTrait {
    fn new(
        emit: UsersEmitter,
        model: UsersList,
    ) -> Self;
    fn emit(&mut self) -> &mut UsersEmitter;
    fn filter(&self) -> &str;
    fn set_filter(
        &mut self,
        value: String,
    );
    fn filter_regex(&self) -> bool;
    fn set_filter_regex(
        &mut self,
        value: bool,
    );
    fn add(
        &mut self,
        id: String,
    ) -> Vec<u8>;
    fn clear_filter(&mut self) -> ();
    fn color_by_id(
        &self,
        id: String,
    ) -> u32;
    fn name_by_id(
        &self,
        id: String,
    ) -> String;
    fn profile_picture_by_id(
        &self,
        id: String,
    ) -> String;
    fn toggle_filter_regex(&mut self) -> bool;
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn color(
        &self,
        index: usize,
    ) -> u32;
    fn set_color(
        &mut self,
        index: usize,
        _: u32,
    ) -> bool;
    fn matched(
        &self,
        index: usize,
    ) -> bool;
    fn name(
        &self,
        index: usize,
    ) -> String;
    fn set_name(
        &mut self,
        index: usize,
        _: String,
    ) -> bool;
    fn pairwise_conversation_id(
        &self,
        index: usize,
    ) -> Vec<u8>;
    fn profile_picture(
        &self,
        index: usize,
    ) -> Option<String>;
    fn set_profile_picture(
        &mut self,
        index: usize,
        _: Option<String>,
    ) -> bool;
    fn status(
        &self,
        index: usize,
    ) -> u8;
    fn set_status(
        &mut self,
        index: usize,
        _: u8,
    ) -> bool;
    fn user_id(
        &self,
        index: usize,
    ) -> &str;
}

#[no_mangle]
pub extern "C" fn users_new(
    users: *mut UsersQObject,
    users_filter_changed: fn(*mut UsersQObject),
    users_filter_regex_changed: fn(*mut UsersQObject),
    users_new_data_ready: fn(*mut UsersQObject),
    users_layout_about_to_be_changed: fn(*mut UsersQObject),
    users_layout_changed: fn(*mut UsersQObject),
    users_data_changed: fn(*mut UsersQObject, usize, usize),
    users_begin_reset_model: fn(*mut UsersQObject),
    users_end_reset_model: fn(*mut UsersQObject),
    users_begin_insert_rows: fn(*mut UsersQObject, usize, usize),
    users_end_insert_rows: fn(*mut UsersQObject),
    users_begin_move_rows: fn(*mut UsersQObject, usize, usize, usize),
    users_end_move_rows: fn(*mut UsersQObject),
    users_begin_remove_rows: fn(*mut UsersQObject, usize, usize),
    users_end_remove_rows: fn(*mut UsersQObject),
) -> *mut Users {
    let users_emit = UsersEmitter {
        qobject: Arc::new(AtomicPtr::new(users)),
        filter_changed: users_filter_changed,
        filter_regex_changed: users_filter_regex_changed,
        new_data_ready: users_new_data_ready,
    };
    let model = UsersList {
        qobject: users,
        layout_about_to_be_changed: users_layout_about_to_be_changed,
        layout_changed: users_layout_changed,
        data_changed: users_data_changed,
        begin_reset_model: users_begin_reset_model,
        end_reset_model: users_end_reset_model,
        begin_insert_rows: users_begin_insert_rows,
        end_insert_rows: users_end_insert_rows,
        begin_move_rows: users_begin_move_rows,
        end_move_rows: users_end_move_rows,
        begin_remove_rows: users_begin_remove_rows,
        end_remove_rows: users_end_remove_rows,
    };
    let d_users = Users::new(users_emit, model);
    Box::into_raw(Box::new(d_users))
}

#[no_mangle]
pub unsafe extern "C" fn users_free(ptr: *mut Users) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn users_filter_get(
    ptr: *const Users,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.filter();
    let s: *const c_char = v.as_ptr() as (*const c_char);
    set(p, s, to_c_int(v.len()));
}

#[no_mangle]
pub unsafe extern "C" fn users_filter_set(
    ptr: *mut Users,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_filter(s);
}

#[no_mangle]
pub unsafe extern "C" fn users_filter_regex_get(ptr: *const Users) -> bool {
    (&*ptr).filter_regex()
}

#[no_mangle]
pub unsafe extern "C" fn users_filter_regex_set(
    ptr: *mut Users,
    v: bool,
) {
    (&mut *ptr).set_filter_regex(v);
}

#[no_mangle]
pub unsafe extern "C" fn users_add(
    ptr: *mut Users,
    id_str: *const c_ushort,
    id_len: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, str: *const c_char, len: c_int),
) {
    let mut id = String::new();
    set_string_from_utf16(&mut id, id_str, id_len);
    let o = &mut *ptr;
    let r = o.add(id);
    let s: *const c_char = r.as_ptr() as (*const c_char);
    set(d, s, r.len() as i32);
}

#[no_mangle]
pub unsafe extern "C" fn users_clear_filter(ptr: *mut Users) {
    let o = &mut *ptr;
    o.clear_filter()
}

#[no_mangle]
pub unsafe extern "C" fn users_color_by_id(
    ptr: *const Users,
    id_str: *const c_ushort,
    id_len: c_int,
) -> u32 {
    let mut id = String::new();
    set_string_from_utf16(&mut id, id_str, id_len);
    let o = &*ptr;
    o.color_by_id(id)
}

#[no_mangle]
pub unsafe extern "C" fn users_name_by_id(
    ptr: *const Users,
    id_str: *const c_ushort,
    id_len: c_int,
    d: *mut QString,
    set: fn(*mut QString, str: *const c_char, len: c_int),
) {
    let mut id = String::new();
    set_string_from_utf16(&mut id, id_str, id_len);
    let o = &*ptr;
    let r = o.name_by_id(id);
    let s: *const c_char = r.as_ptr() as (*const c_char);
    set(d, s, r.len() as i32);
}

#[no_mangle]
pub unsafe extern "C" fn users_profile_picture_by_id(
    ptr: *const Users,
    id_str: *const c_ushort,
    id_len: c_int,
    d: *mut QString,
    set: fn(*mut QString, str: *const c_char, len: c_int),
) {
    let mut id = String::new();
    set_string_from_utf16(&mut id, id_str, id_len);
    let o = &*ptr;
    let r = o.profile_picture_by_id(id);
    let s: *const c_char = r.as_ptr() as (*const c_char);
    set(d, s, r.len() as i32);
}

#[no_mangle]
pub unsafe extern "C" fn users_toggle_filter_regex(ptr: *mut Users) -> bool {
    let o = &mut *ptr;
    o.toggle_filter_regex()
}

#[no_mangle]
pub unsafe extern "C" fn users_row_count(ptr: *const Users) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn users_insert_rows(
    ptr: *mut Users,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_remove_rows(
    ptr: *mut Users,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_can_fetch_more(ptr: *const Users) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn users_fetch_more(ptr: *mut Users) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn users_sort(
    ptr: *mut Users,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn users_data_color(
    ptr: *const Users,
    row: c_int,
) -> u32 {
    let o = &*ptr;
    o.color(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn users_set_data_color(
    ptr: *mut Users,
    row: c_int,
    v: u32,
) -> bool {
    (&mut *ptr).set_color(to_usize(row).unwrap_or(0), v)
}

#[no_mangle]
pub unsafe extern "C" fn users_data_matched(
    ptr: *const Users,
    row: c_int,
) -> bool {
    let o = &*ptr;
    o.matched(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn users_data_name(
    ptr: *const Users,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.name(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

#[no_mangle]
pub unsafe extern "C" fn users_set_data_name(
    ptr: *mut Users,
    row: c_int,
    s: *const c_ushort,
    len: c_int,
) -> bool {
    let o = &mut *ptr;
    let mut v = String::new();
    set_string_from_utf16(&mut v, s, len);
    o.set_name(to_usize(row).unwrap_or(0), v)
}

#[no_mangle]
pub unsafe extern "C" fn users_data_pairwise_conversation_id(
    ptr: *const Users,
    row: c_int,
    d: *mut QByteArray,
    set: fn(*mut QByteArray, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.pairwise_conversation_id(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

#[no_mangle]
pub unsafe extern "C" fn users_data_profile_picture(
    ptr: *const Users,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.profile_picture(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_set_data_profile_picture(
    ptr: *mut Users,
    row: c_int,
    s: *const c_ushort,
    len: c_int,
) -> bool {
    let o = &mut *ptr;
    let mut v = String::new();
    set_string_from_utf16(&mut v, s, len);
    o.set_profile_picture(to_usize(row).unwrap_or(0), Some(v))
}

#[no_mangle]
pub unsafe extern "C" fn users_set_data_profile_picture_none(
    ptr: *mut Users,
    row: c_int,
) -> bool {
    (&mut *ptr).set_profile_picture(to_usize(row).unwrap_or(0), None)
}

#[no_mangle]
pub unsafe extern "C" fn users_data_status(
    ptr: *const Users,
    row: c_int,
) -> u8 {
    let o = &*ptr;
    o.status(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn users_set_data_status(
    ptr: *mut Users,
    row: c_int,
    v: u8,
) -> bool {
    (&mut *ptr).set_status(to_usize(row).unwrap_or(0), v)
}

#[no_mangle]
pub unsafe extern "C" fn users_data_user_id(
    ptr: *const Users,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.user_id(to_usize(row).unwrap_or(0));
    let s: *const c_char = data.as_ptr() as (*const c_char);
    set(d, s, to_c_int(data.len()));
}

pub struct UsersSearchQObject {}

pub struct UsersSearchEmitter {
    qobject: Arc<AtomicPtr<UsersSearchQObject>>,
    filter_changed: fn(*mut UsersSearchQObject),
    new_data_ready: fn(*mut UsersSearchQObject),
}

impl UsersSearchEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> UsersSearchEmitter {
        UsersSearchEmitter {
            qobject: self.qobject.clone(),
            filter_changed: self.filter_changed,
            new_data_ready: self.new_data_ready,
        }
    }
    fn clear(&self) {
        let n: *const UsersSearchQObject = null();
        self.qobject
            .store(n as *mut UsersSearchQObject, Ordering::SeqCst);
    }
    pub fn filter_changed(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.filter_changed)(ptr);
        }
    }
    pub fn new_data_ready(&mut self) {
        let ptr = self.qobject.load(Ordering::SeqCst);
        if !ptr.is_null() {
            (self.new_data_ready)(ptr);
        }
    }
}

#[derive(Clone)]
pub struct UsersSearchList {
    qobject: *mut UsersSearchQObject,
    layout_about_to_be_changed: fn(*mut UsersSearchQObject),
    layout_changed: fn(*mut UsersSearchQObject),
    data_changed: fn(*mut UsersSearchQObject, usize, usize),
    begin_reset_model: fn(*mut UsersSearchQObject),
    end_reset_model: fn(*mut UsersSearchQObject),
    begin_insert_rows: fn(*mut UsersSearchQObject, usize, usize),
    end_insert_rows: fn(*mut UsersSearchQObject),
    begin_move_rows: fn(*mut UsersSearchQObject, usize, usize, usize),
    end_move_rows: fn(*mut UsersSearchQObject),
    begin_remove_rows: fn(*mut UsersSearchQObject, usize, usize),
    end_remove_rows: fn(*mut UsersSearchQObject),
}

impl UsersSearchList {
    pub fn layout_about_to_be_changed(&mut self) {
        (self.layout_about_to_be_changed)(self.qobject);
    }
    pub fn layout_changed(&mut self) {
        (self.layout_changed)(self.qobject);
    }
    pub fn data_changed(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.data_changed)(self.qobject, first, last);
    }
    pub fn begin_reset_model(&mut self) {
        (self.begin_reset_model)(self.qobject);
    }
    pub fn end_reset_model(&mut self) {
        (self.end_reset_model)(self.qobject);
    }
    pub fn begin_insert_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_insert_rows)(self.qobject, first, last);
    }
    pub fn end_insert_rows(&mut self) {
        (self.end_insert_rows)(self.qobject);
    }
    pub fn begin_move_rows(
        &mut self,
        first: usize,
        last: usize,
        destination: usize,
    ) {
        (self.begin_move_rows)(self.qobject, first, last, destination);
    }
    pub fn end_move_rows(&mut self) {
        (self.end_move_rows)(self.qobject);
    }
    pub fn begin_remove_rows(
        &mut self,
        first: usize,
        last: usize,
    ) {
        (self.begin_remove_rows)(self.qobject, first, last);
    }
    pub fn end_remove_rows(&mut self) {
        (self.end_remove_rows)(self.qobject);
    }
}

pub trait UsersSearchTrait {
    fn new(
        emit: UsersSearchEmitter,
        model: UsersSearchList,
    ) -> Self;
    fn emit(&mut self) -> &mut UsersSearchEmitter;
    fn filter(&self) -> Option<&str>;
    fn set_filter(
        &mut self,
        value: Option<String>,
    );
    fn clear_filter(&mut self) -> ();
    fn refresh(&mut self) -> ();
    fn row_count(&self) -> usize;
    fn insert_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn remove_rows(
        &mut self,
        _row: usize,
        _count: usize,
    ) -> bool {
        false
    }
    fn can_fetch_more(&self) -> bool {
        false
    }
    fn fetch_more(&mut self) {}
    fn sort(
        &mut self,
        _: u8,
        _: SortOrder,
    ) {
    }
    fn color(
        &self,
        index: usize,
    ) -> Option<u32>;
    fn matched(
        &self,
        index: usize,
    ) -> bool;
    fn name(
        &self,
        index: usize,
    ) -> Option<String>;
    fn profile_picture(
        &self,
        index: usize,
    ) -> Option<String>;
    fn selected(
        &self,
        index: usize,
    ) -> bool;
    fn set_selected(
        &mut self,
        index: usize,
        _: bool,
    ) -> bool;
    fn user_id(
        &self,
        index: usize,
    ) -> Option<&str>;
}

#[no_mangle]
pub extern "C" fn users_search_new(
    users_search: *mut UsersSearchQObject,
    users_search_filter_changed: fn(*mut UsersSearchQObject),
    users_search_new_data_ready: fn(*mut UsersSearchQObject),
    users_search_layout_about_to_be_changed: fn(*mut UsersSearchQObject),
    users_search_layout_changed: fn(*mut UsersSearchQObject),
    users_search_data_changed: fn(*mut UsersSearchQObject, usize, usize),
    users_search_begin_reset_model: fn(*mut UsersSearchQObject),
    users_search_end_reset_model: fn(*mut UsersSearchQObject),
    users_search_begin_insert_rows: fn(*mut UsersSearchQObject, usize, usize),
    users_search_end_insert_rows: fn(*mut UsersSearchQObject),
    users_search_begin_move_rows: fn(*mut UsersSearchQObject, usize, usize, usize),
    users_search_end_move_rows: fn(*mut UsersSearchQObject),
    users_search_begin_remove_rows: fn(*mut UsersSearchQObject, usize, usize),
    users_search_end_remove_rows: fn(*mut UsersSearchQObject),
) -> *mut UsersSearch {
    let users_search_emit = UsersSearchEmitter {
        qobject: Arc::new(AtomicPtr::new(users_search)),
        filter_changed: users_search_filter_changed,
        new_data_ready: users_search_new_data_ready,
    };
    let model = UsersSearchList {
        qobject: users_search,
        layout_about_to_be_changed: users_search_layout_about_to_be_changed,
        layout_changed: users_search_layout_changed,
        data_changed: users_search_data_changed,
        begin_reset_model: users_search_begin_reset_model,
        end_reset_model: users_search_end_reset_model,
        begin_insert_rows: users_search_begin_insert_rows,
        end_insert_rows: users_search_end_insert_rows,
        begin_move_rows: users_search_begin_move_rows,
        end_move_rows: users_search_end_move_rows,
        begin_remove_rows: users_search_begin_remove_rows,
        end_remove_rows: users_search_end_remove_rows,
    };
    let d_users_search = UsersSearch::new(users_search_emit, model);
    Box::into_raw(Box::new(d_users_search))
}

#[no_mangle]
pub unsafe extern "C" fn users_search_free(ptr: *mut UsersSearch) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn users_search_filter_get(
    ptr: *const UsersSearch,
    p: *mut QString,
    set: fn(*mut QString, *const c_char, c_int),
) {
    let o = &*ptr;
    let v = o.filter();
    if let Some(v) = v {
        let s: *const c_char = v.as_ptr() as (*const c_char);
        set(p, s, to_c_int(v.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_search_filter_set(
    ptr: *mut UsersSearch,
    v: *const c_ushort,
    len: c_int,
) {
    let o = &mut *ptr;
    let mut s = String::new();
    set_string_from_utf16(&mut s, v, len);
    o.set_filter(Some(s));
}

#[no_mangle]
pub unsafe extern "C" fn users_search_filter_set_none(ptr: *mut UsersSearch) {
    let o = &mut *ptr;
    o.set_filter(None);
}

#[no_mangle]
pub unsafe extern "C" fn users_search_clear_filter(ptr: *mut UsersSearch) {
    let o = &mut *ptr;
    o.clear_filter()
}

#[no_mangle]
pub unsafe extern "C" fn users_search_refresh(ptr: *mut UsersSearch) {
    let o = &mut *ptr;
    o.refresh()
}

#[no_mangle]
pub unsafe extern "C" fn users_search_row_count(ptr: *const UsersSearch) -> c_int {
    to_c_int((&*ptr).row_count())
}

#[no_mangle]
pub unsafe extern "C" fn users_search_insert_rows(
    ptr: *mut UsersSearch,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).insert_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_search_remove_rows(
    ptr: *mut UsersSearch,
    row: c_int,
    count: c_int,
) -> bool {
    match (to_usize(row), to_usize(count)) {
        (Some(row), Some(count)) => (&mut *ptr).remove_rows(row, count),
        _ => false,
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_search_can_fetch_more(ptr: *const UsersSearch) -> bool {
    (&*ptr).can_fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn users_search_fetch_more(ptr: *mut UsersSearch) {
    (&mut *ptr).fetch_more()
}

#[no_mangle]
pub unsafe extern "C" fn users_search_sort(
    ptr: *mut UsersSearch,
    column: u8,
    order: SortOrder,
) {
    (&mut *ptr).sort(column, order)
}

#[no_mangle]
pub unsafe extern "C" fn users_search_data_color(
    ptr: *const UsersSearch,
    row: c_int,
) -> COption<u32> {
    let o = &*ptr;
    o.color(to_usize(row).unwrap_or(0)).into()
}

#[no_mangle]
pub unsafe extern "C" fn users_search_data_matched(
    ptr: *const UsersSearch,
    row: c_int,
) -> bool {
    let o = &*ptr;
    o.matched(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn users_search_data_name(
    ptr: *const UsersSearch,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.name(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_search_data_profile_picture(
    ptr: *const UsersSearch,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.profile_picture(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

#[no_mangle]
pub unsafe extern "C" fn users_search_data_selected(
    ptr: *const UsersSearch,
    row: c_int,
) -> bool {
    let o = &*ptr;
    o.selected(to_usize(row).unwrap_or(0))
}

#[no_mangle]
pub unsafe extern "C" fn users_search_set_data_selected(
    ptr: *mut UsersSearch,
    row: c_int,
    v: bool,
) -> bool {
    (&mut *ptr).set_selected(to_usize(row).unwrap_or(0), v)
}

#[no_mangle]
pub unsafe extern "C" fn users_search_data_user_id(
    ptr: *const UsersSearch,
    row: c_int,
    d: *mut QString,
    set: fn(*mut QString, *const c_char, len: c_int),
) {
    let o = &*ptr;
    let data = o.user_id(to_usize(row).unwrap_or(0));
    if let Some(data) = data {
        let s: *const c_char = data.as_ptr() as (*const c_char);
        set(d, s, to_c_int(data.len()));
    }
}

pub struct UtilsQObject {}

pub struct UtilsEmitter {
    qobject: Arc<AtomicPtr<UtilsQObject>>,
}

impl UtilsEmitter {
    /// Clone the emitter
    ///
    /// The emitter can only be cloned when it is mutable. The emitter calls
    /// into C++ code which may call into Rust again. If emmitting is possible
    /// from immutable structures, that might lead to access to a mutable
    /// reference. That is undefined behaviour and forbidden.
    pub fn clone(&mut self) -> UtilsEmitter {
        UtilsEmitter {
            qobject: self.qobject.clone(),
        }
    }
    fn clear(&self) {
        let n: *const UtilsQObject = null();
        self.qobject.store(n as *mut UtilsQObject, Ordering::SeqCst);
    }
}

pub trait UtilsTrait {
    fn new(emit: UtilsEmitter) -> Self;
    fn emit(&mut self) -> &mut UtilsEmitter;
    fn compare_byte_array(
        &self,
        bs1: &[u8],
        bs2: &[u8],
    ) -> bool;
    fn is_valid_rand_id(
        &self,
        bs: &[u8],
    ) -> bool;
}

#[no_mangle]
pub extern "C" fn utils_new(utils: *mut UtilsQObject) -> *mut Utils {
    let utils_emit = UtilsEmitter {
        qobject: Arc::new(AtomicPtr::new(utils)),
    };
    let d_utils = Utils::new(utils_emit);
    Box::into_raw(Box::new(d_utils))
}

#[no_mangle]
pub unsafe extern "C" fn utils_free(ptr: *mut Utils) {
    Box::from_raw(ptr).emit().clear();
}

#[no_mangle]
pub unsafe extern "C" fn utils_compare_byte_array(
    ptr: *const Utils,
    bs1_str: *const c_char,
    bs1_len: c_int,
    bs2_str: *const c_char,
    bs2_len: c_int,
) -> bool {
    let bs1 = { qba_slice!(bs1_str, bs1_len) };
    let bs2 = { qba_slice!(bs2_str, bs2_len) };
    let o = &*ptr;
    o.compare_byte_array(bs1, bs2)
}

#[no_mangle]
pub unsafe extern "C" fn utils_is_valid_rand_id(
    ptr: *const Utils,
    bs_str: *const c_char,
    bs_len: c_int,
) -> bool {
    let bs = { qba_slice!(bs_str, bs_len) };
    let o = &*ptr;
    o.is_valid_rand_id(bs)
}
